# Module 1 Hello, Python!

# Helpful resources and tips

As a learner, you can choose to complete one or multiple courses in this program. However, to obtain the certificate, you must complete all the courses in the program. This reading describes what is required to obtain a certificate and best practices for you to have a good learning experience on Coursera.  

## Obtain the Google Advanced Data Analytics Certificate

To receive your official Google Advanced Data Analytics Certificate, you must:

- Pass all graded assignments in all 7 courses of the certificate program. Each graded assignment is part of a cumulative graded score for the course, and the passing grade for each course is 80%. 
    

AND **one** of the following:

- Pay the [course certificate fee](https://www.coursera.support/s/article/209818963-Payments-on-Coursera?language=en_US),
    
- Be approved for [Coursera Financial Aid](https://www.coursera.support/s/article/209819033-Apply-for-Financial-Aid-or-a-Scholarship?language=en_US), **or**
    
- Complete the certificate through an educational institution, employer, or agency that's sponsoring your participation. 
    

## Healthy habits for course completion

Here is a list of best practices that will help you complete the courses in the program in a timely manner:

- **Plan your time:** Setting regular study times and following them each week can help you make learning a part of your routine. Use a calendar or timetable to create a schedule, and list what you plan to do each day in order to set achievable goals. Find a space that allows you to focus when you watch the videos, review the readings, and complete the activities.
    
- **Work at your own pace:** Everyone learns differently, so this program has been designed to let you work at your own pace. Although your personalized deadlines start when you enroll, feel free to progress through the program at the speed that works best for you. There is no penalty for late assignments; to earn your certificate, all you have to do is complete all of the work. You can extend your deadlines at any time by going to **Overview** in the navigation panel and selecting **Switch Sessions**. If you have already missed previous deadlines, select **Reset my deadlines** instead.
    
- **Be curious:** If you find an idea that gets you excited, act on it! Ask questions, search for more details online, explore the links that interest you, and take notes on your discoveries. The steps you take to support your learning along the way will advance your knowledge, create more opportunities in this high-growth field, and help you qualify for jobs. 
    
- **Take notes:** Notes will help you remember important information in the future, especially as you’re preparing to enter a new job field. In addition, taking notes is an effective way to make connections between topics and gain a better understanding of those topics.
    
- **Review exemplars:** Exemplars are completed assignments that fully meet an activity's criteria. Many activities in this program have exemplars for you to compare to your own work. Although there are often many ways to complete an assignment, exemplars offer you guidance and inspiration about how to complete the activity. 
    
- **Chat (responsibly) with other learners:** If you have a question, chances are, you’re not alone. Use the [discussion forums](https://www.coursera.org/learn/get-started-with-python/discussions) to ask for help from other learners taking this program. You can also visit Coursera’s [Global Online Community](https://coursera.community/). Other important things to know while learning with others can be found in the [Coursera Honor Code](https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code) and [Code of Conduct](https://learner.coursera.help/hc/en-us/articles/208280036-Coursera-Code-of-Conduct). 
    
- **Update your profile:** Consider [updating your profile](https://www.coursera.org/account/profile) on Coursera to include your photo, career goals, and more. When other learners find you in the discussion forums, they can click on your name to access your profile and get to know you better.
    

## Documents, spreadsheets, presentations, and labs for course activities

To complete certain activities in the program, you will need to use digital documents, spreadsheets, presentations, and/or labs. Data analytics professionals use these software applications to collaborate within their teams and organizations. If you need more information about using a particular tool, refer to these resources:

- [Microsoft Word: Help and learning](https://support.microsoft.com/en-us/word): Microsoft Support page for Word
    
- [Google Docs](https://support.google.com/docs/topic/9046002?hl=en&ref_topic=1382883): Help Center page for Google Docs
    
- [Microsoft Excel: Help and learning](https://support.microsoft.com/en-us/excel): Microsoft Support page for Excel
    
- [Google Sheets](https://support.google.com/docs/topic/9054603?hl=en&ref_topic=1382883): Help Center page for Google Sheets
    
- [Microsoft PowerPoint: Help and learning](https://support.microsoft.com/en-us/powerpoint): Microsoft Support page for PowerPoint
    
- [How to use Google Slides](https://support.google.com/docs/answer/2763168?hl=en&co=GENIE.Platform%3DDesktop): Help Center page for Google Slides  
    
- [Common problems with labs](https://support.google.com/qwiklabs/answer/9133560?hl=en&ref_topic=9134804): Troubleshooting help for Qwiklabs activities
    

## Module, course, and certificate glossaries

This program covers a lot of terms and concepts, some of which you may already know and some of which may be unfamiliar to you. To review terms and help you prepare for graded quizzes, refer to the following glossaries:

- **Module glossaries**: At the end of each module’s content, you can review a glossary of terms from that module. Each module’s glossary builds upon the terms from the previous modules in that course. The module glossaries are not downloadable; however, all of the terms and definitions are included in the course and certificate glossaries, which are downloadable.
    
- **Course glossaries**: At the end of each course, you can access and download a glossary that covers all of the terms in that course. 
    
- **Certificate glossary**: The certificate glossary includes all of the terms in the entire certificate program and is a helpful resource that you can reference throughout the program or at any time in the future. 
    

You can access and download the certificate glossaries and **save them on your computer.** You can **always find the** course and certificate glossaries through each course’s Resources section. To access the **Advanced Data Analytics Certificate glossary**, click the link below and select _Use Template_.

- Link to the glossary: [Advanced Data Analytics Certificate glossary](https://docs.google.com/document/d/193-AtS7MlB2w4buwiCyPjBoOhIbbByKgHWPpYnSR9VI/template/preview)
    

OR

- If you don’t have a Google account, you can download the glossary directly from the following attachment.
    

[file](https://d3c33hcgiwev3.cloudfront.net/hh5fTi8iRiSd_QFMpbgudg_6afdc847dcb2418a8d6626674ce6a5f1_Advanced-Data-Analytics-Certificate-glossary.docx?Expires=1710028800&Signature=KjJ9bNd3W30F2ZzSrFx05tkczOeAxkHSTm-XiWpvCHzg0btL9D-iYigNnPoJdaoWVGALuOLNwq-Uwotm6uJwAJeyNBShscII7AkRZQixZ3O~vMFmdJCRwg7XwJTy~1SEil3MMFwVhXZcH~85SGZKQr~aBk9GRQmj-JB6QKwqOlM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Data Analytics Certificate glossary

If you completed the original [Google Data Analytics Certificate](https://www.coursera.org/professional-certificates/google-data-analytics?utm_source=google&utm_medium=institutions&utm_campaign=gwgsite-gDigital-paidha-sem-bk-gen-exa-glp-br-null&_ga=2.170664992.1625030801.1661901112-1742325342.1661901112), you may recognize some overlap with several of the glossary terms in this program. Refer to the Data Analytics Certificate glossary, linked in the [Resources](https://www.coursera.org/learn/get-started-with-python/resources/E23KB) tab, to review these foundational terms and concepts. The definitions of some terms in the Data Analytics Certificate glossary differ from the definitions of the same terms in this program since the Advanced Data Analytics Certificate builds upon the concepts taught in the previous program.

## Course feedback

Providing feedback on videos, readings, and other materials is easy. With the resource open in your browser, you can find the thumbs-up and thumbs-down symbols. 

- Click **thumbs-up** for materials you find helpful. 
    
- Click **thumbs-down** for materials that you do not find helpful.
    

If you want to flag a specific issue with an item, click the flag icon, select a category, and enter an explanation in the text box. This feedback goes back to the course development team and isn’t visible to other learners. All feedback received helps to create even better certificate programs in the future.

For technical help, visit the [Learner Help Center](https://learner.coursera.help/hc/en-us).

<br> 

*** 

<br>

# Course 2 overview

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/19947469-cb87-4f70-9f17-a830f9104b89)

Hello, and welcome to **Get Started with Python**, the second course in the Google Advanced Data Analytics Certificate. You’re on an exciting journey!

Throughout this course, you will develop an understanding of Python syntax, logic, data types, objects, and object-oriented programming. For many professionals, Python is the key to unlocking advanced analytics, machine learning, and the world of data science. By the end of this course, you will better understand how data scientists use programming on the job and how Python will be an important tool throughout your career as a data analytics professional.

## Course descriptions

The Google Advanced Data Analytics Certificate has seven courses. **Get Started with Python** is the second course.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/f6bae109-7c8a-416c-841f-8ed3db9450e7)

1. [**Foundations of Data Science**](https://www.coursera.org/learn/foundations-of-data-science/home/week/1) — Learn how data professionals operate in the workplace and how different roles in the field of data science contribute to an organization’s vision of the future. Then, explore data science roles, communication skills, and data ethics.
    
2. [**Get Started with Python**](https://www.coursera.org/learn/get-started-with-python/home/week/1) — _(current course)_ Discover how the programming language Python can power your data analysis. Learn core Python concepts, such as data types, functions, conditional statements, loops, and data structures.
    
3. [**Go Beyond the Numbers: Translate Data into Insights**](https://www.coursera.org/learn/go-beyond-the-numbers-translate-data-into-insight/home/week/1) — Learn the fundamentals of data cleaning and visualizations and how to reveal the important stories that live within data.
    
4. [**The Power of Statistics**](https://www.coursera.org/learn/the-power-of-statistics/home/week/1) — Explore descriptive and inferential statistics, basic probability and probability distributions, sampling, confidence intervals, and hypothesis testing.
    
5. [**Regression Analysis: Simplify Complex Data Relationships**](https://www.coursera.org/learn/regression-analysis-simplify-complex-data-relationships/home/week/1) — Learn to model variable relationships, focusing on linear and logistic regression.
    
6. [**The Nuts and Bolts of Machine Learning**](https://www.coursera.org/learn/the-nuts-and-bolts-of-machine-learning/home/week/1) — Learn unsupervised machine learning techniques and how to apply them to organizational data. 
    
7. [**Google Advanced Data Analytics Capstone**](https://www.coursera.org/learn/google-advanced-data-analytics-capstone/home/week/1) — Complete a hands-on project designed to demonstrate the skills and competencies you acquire in the program. 
    

## Course 2 content

Each course of this certificate program is broken into modules. You can complete courses at your own pace, but the module breakdowns are designed to help you finish the entire Google Advanced Data Analytics Certificate in about six months.

What’s to come? Here’s a quick overview of the skills you’ll learn in each module of this course.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/0ddd8965-89b4-422b-a573-8b4e84138f27)

**Module 1: Hello, Python!** 

You’ll begin by exploring the basics of Python programming and why Python is such a powerful tool for data analysis. You’ll learn about Jupyter Notebooks, an interactive environment for coding and data work. You’ll investigate how to use variables and data types to store and organize your data; and, you'll begin practicing some important coding skills.

**Module 2: Functions and conditional statements**

Next, you’ll discover how to call functions to perform useful actions on your data. You’ll also learn how to write conditional statements to tell the computer how to make decisions based on your instructions. And you’ll practice writing clean code that can be easily understood and reused by other data professionals.

**Module 3: Loops and strings**

After that, you’ll learn how to use iterative statements, or loops, to automate repetitive tasks. You’ll also learn how to manipulate strings using slicing, indexing, and formatting. 

**Module 4: Data structures in Python**

Then, you’ll explore fundamental data structures such as lists, tuples, dictionaries, sets, and arrays. Lastly, you’ll learn about two of the most widely used and important Python tools for advanced data analysis: NumPy and pandas. 

**Module 5: Course 2 end-of-course project**

At the end of this course, you will put everything you have learned about Python so far into practice with an end-of-course project. You will select a business problem from a list of options and use the given data to solve the problem. This project is an opportunity to demonstrate your skills and build a professional portfolio you can use to showcase your work to potential employers. 

## What to expect

Each course offers many types of learning opportunities:

- **Videos** led by Google instructors teach new concepts, introduce the use of relevant tools, offer career support, and provide inspirational personal stories. 
    
- **Readings** build on the topics discussed in the videos, introduce related concepts, share useful resources, and describe case studies.
    
- **Discussion prompts** explore course topics for better understanding and allow you to chat and exchange ideas with other learners in the [**discussion forums**](https://www.coursera.org/learn/get-started-with-python/discussions).
    
- **Self-review activities** and **labs** give you hands-on practice in applying the skills you are learning and allow you to assess your own work by comparing it to a completed example.
    
- **In-video quizzes** help you check your comprehension as you progress through each video.
    
- **Practice quizzes** allow you to check your understanding of key concepts and provide valuable feedback.
    
- **Graded quizzes** demonstrate your understanding of the main concepts of a course. You must score 80% or higher on each graded quiz to obtain a certificate, and you can take a graded quiz multiple times to achieve a passing score.
    

## Tips for success

- It is strongly recommended that you go through the items in each lesson in the order they appear because new information and concepts build on previous knowledge.
    
- Participate in all learning opportunities to gain as much knowledge and experience as possible.
    
- If something is confusing, don’t hesitate to replay a video, review a reading, or repeat a self-review activity.
    
- Use the additional resources that are referenced in this course. They are designed to support your learning. You can find all of these resources in the [**Resources**](https://www.coursera.org/learn/get-started-with-python/resources/GnHn1) tab.
    
- When you encounter useful links in this course, bookmark them so you can refer to the information later for study or review.
    
- Understand and follow the [Coursera Code of Conduct](https://www.coursera.support/s/article/208280036-Coursera-Code-of-Conduct?) to ensure that the learning community remains a welcoming, friendly, and supportive place for all members.


<br> 

*** 

<br>

# Python versus other programming languages

Python is one of the most popular programming languages for data professionals, which makes it a great addition to your data analytics toolbox! As we’ve previously investigated, Python’s use of syntax to communicate commands and perform tasks mirrors spoken language. This makes Python a much easier programming language to learn. Python’s structure is similar to many other programming languages, but there are some key differences to consider as well.

In this reading, you’ll learn how Python compares to other programming languages data professionals use, including R, Java, and C++. 

## Five considerations of programming languages

Python isn’t the only programming language used for data analysis, but it is one of the most widely used and most powerful. Many data professionals even use more than one programming language. Every language has benefits and drawbacks. For the purposes of this course, examine the following considerations: speed, approachability, variables, data science focus, and programming paradigm.

### **Speed**

There are many factors that contribute to the speed of a program’s execution, including compile time, runtime, hardware, installed dependencies, and the efficiency of the code itself. In general, low-level programming languages are faster, but they’re more difficult to learn and work with. 

### **Approachability**

Approachability refers to how easy it is for new learners to start using a language. Learning new programming languages can be challenging depending on their syntax and overall structure. The **syntax** is the structure of code words, symbols, placement, and punctuation. Semantics builds meaning into those structures by using variables and objects. Additionally, those variables help add flexibility to the programs and objects where data is housed. 

### **Variables**

Information in code is stored in variables. A **variable** is a named container which stores values in a reserved location in the computer’s memory. The way a programming language uses variables will have an effect on a system's core operations or kernel speed. Some languages use static variables to maintain a value throughout the entire run of a program. Others approach variables as dynamic, allowing values to be determined when a program is run. Some languages even allow declarative variables, which enable a program to determine where a variable should be placed. 

### **Data science focus**

Programming languages have individual characteristics and can better serve different tasks in data analysis; this means programmers often use them for specific data science tasks. 

### **Programming paradigm**

Programming languages can be object-oriented, functional, or imperative. Object-oriented programming languages are modeled around data objects. Functional programming languages are modeled around functions. Imperative languages are modeled around code statements that can alter the state of the program itself. 

## Programming language comparisons

Python, R, Java and C++ are four of the most commonly used programming languages for data analysis. The following chart compares them using five considerations: speed, accessibility, variable, data science focus, and programming paradigm. 

|**Features by Software**|**Python**|**R**|**Java**|**C++**|
|---|---|---|---|---|
|**Speed**|Slower|Depends on configuration and add-ons|Faster|Very fast|
|**Approachability**|Easy to learn|Complex|Easy to learn|Complex|
|**Variable**|Dynamic|Dynamic|Static|Declarative|
|**Data science focus**|Machine learning and automated analysis|Exploratory data analysis and building extensive statistical libraries|Used across projects with open-source assets|Not as widely used but very powerful implementations|
|**Programming Paradigm**|Object-oriented|Functional language|Object-oriented|Multi-paradigm (imperative & object-oriented)|

## Key takeaways

There are a number of different programming languages that can be used for data analysis. Each language has its own benefits and drawbacks. Learning to work with different languages will give you the opportunity to broaden your data skills and access new tools for your analysis. However, in this certificate program, Python will be your sole focus. As mentioned previously, Python is an easy to learn, object-oriented programming language that engages dynamic variables; though it sometimes requires a longer time to execute, it is a great tool for machine learning and automated analysis.# How to use Jupyter Notebooks

Jupyter Notebook is an open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text. This is a great tool to develop and present code in a standardized text block format that is interactive and shareable. You can create code, mathematical formulas, data visualizations, and even freestyle text—all in Jupyter notebooks!

You will be using Jupyter notebooks to write, execute, and present your own code throughout this program. This reading will guide you through using your own notebook. Note, however, that for this certificate program you do not need to download any software. You can complete all activities with the tools provided on the Coursera platform.

# Jupyter Notebook

You can access Jupyter Notebook directly from your browser or download the desktop application onto your device to work with over 100 programming languages, including some you might already know like R and Python. There is [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/), which is the full suite of tools for working with computational notebooks. There is also [Jupyter Notebook](https://jupyter-notebook.readthedocs.io/en/stable/), which is a more streamlined and simplified tool that nonetheless offers powerful ways to perform interactive computing. Again, for this certificate program, we recommend working within the Jupyter Notebook interface provided by Coursera. Activities that use Jupyter notebooks will be labeled as labs, and you will find relevant instructions for each activity on its landing page.

# Why Jupyter Notebook?

Notebooks are particularly useful for working with data. Here are some ways that Jupyter notebooks excel:

1. **Modular/interactive computing:** You can write and execute individual chunks of code in small, manageable chunks, which are called cells. You can run a cell without necessarily having to run the whole notebook. This is especially helpful for data exploration and experimentation. Cells are also helpful with debugging, because they provide a user-friendly way to make a mistake, notice that you made the mistake, and iterate back to correct your mistake, without having to re-execute a whole script.
    
2. **Integration of code and documentation:** Notebooks allow you to combine code, textual explanations, and visualizations like charts, graphs, and tables—all in a single document. 
    
3. **Support for multiple languages:** The Advanced Data Analytics program will use Python, but Jupyter notebooks support many other languages, making them powerful and versatile.
    
4. **Data exploration and analysis:** The notebook simplifies working with data by offering tools to load, clean, analyze, and examine it in an elegant interface.
    
5. **Cloud-based services:** Many cloud computing platforms host Jupyter notebooks, which makes it easy to run and share notebooks without setting up a local environment. This is very useful for collaboration.
    
6. **Libraries and extensions:** There is a rich ecosystem of extensions and plugins that enhance functionality for whatever type of project you’re working on. 

<br> 

*** 

<br>

# How to use Jupyter Notebooks

Jupyter Notebook is an open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text. This is a great tool to develop and present code in a standardized text block format that is interactive and shareable. You can create code, mathematical formulas, data visualizations, and even freestyle text—all in Jupyter notebooks!

You will be using Jupyter notebooks to write, execute, and present your own code throughout this program. This reading will guide you through using your own notebook. Note, however, that for this certificate program you do not need to download any software. You can complete all activities with the tools provided on the Coursera platform.

# Jupyter Notebook

You can access Jupyter Notebook directly from your browser or download the desktop application onto your device to work with over 100 programming languages, including some you might already know like R and Python. There is [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/), which is the full suite of tools for working with computational notebooks. There is also [Jupyter Notebook](https://jupyter-notebook.readthedocs.io/en/stable/), which is a more streamlined and simplified tool that nonetheless offers powerful ways to perform interactive computing. Again, for this certificate program, we recommend working within the Jupyter Notebook interface provided by Coursera. Activities that use Jupyter notebooks will be labeled as labs, and you will find relevant instructions for each activity on its landing page.

# Why Jupyter Notebook?

Notebooks are particularly useful for working with data. Here are some ways that Jupyter notebooks excel:

1. **Modular/interactive computing:** You can write and execute individual chunks of code in small, manageable chunks, which are called cells. You can run a cell without necessarily having to run the whole notebook. This is especially helpful for data exploration and experimentation. Cells are also helpful with debugging, because they provide a user-friendly way to make a mistake, notice that you made the mistake, and iterate back to correct your mistake, without having to re-execute a whole script.
    
2. **Integration of code and documentation:** Notebooks allow you to combine code, textual explanations, and visualizations like charts, graphs, and tables—all in a single document. 
    
3. **Support for multiple languages:** The Advanced Data Analytics program will use Python, but Jupyter notebooks support many other languages, making them powerful and versatile.
    
4. **Data exploration and analysis:** The notebook simplifies working with data by offering tools to load, clean, analyze, and examine it in an elegant interface.
    
5. **Cloud-based services:** Many cloud computing platforms host Jupyter notebooks, which makes it easy to run and share notebooks without setting up a local environment. This is very useful for collaboration.
    
6. **Libraries and extensions:** There is a rich ecosystem of extensions and plugins that enhance functionality for whatever type of project you’re working on. 
    

# How to use Jupyter notebooks

Once you’ve opened a Jupyter notebook, it’s time to use it! Here are some tips to get started.

## Command/edit mode

Notebooks have two working modes: command mode and edit mode. Command mode is used to interact with the notebook as a whole and perform actions like adding, moving, and deleting cells. Edit mode is used to type code or markdown text into a particular cell. 

Command mode is indicated by a blue bar on the left side of the current cell.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/8c605b1f-b710-43de-a0de-b64050a63779)

Edit mode is indicated by a green bar on the left and also a thin green border around the active cell.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/7bdf2c52-efb3-4c61-aaf6-f431eb69f944)

To enter into edit mode, simply click into a cell to insert your cursor there or use the navigation arrows on your keyboard to select a cell and press Enter. To revert back to command mode, click anywhere outside the cell or press the escape key.

## Markdown mode

Jupyter notebooks allow you to toggle cells between coding mode and Markdown mode. Markdown is a markup language that lets you add formatting elements to plain text. It’s useful because it’s ubiquitous, future-proof, and platform independent. In Jupyter notebooks, Markdown text is used to provide written explanations, analysis, and context to explain the code and its output. In the following example, all of the text above In [41]: was written and formatted using Markdown.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/00f6815a-fca8-4a6d-b838-038a55f64580)

To toggle between code and Markdown mode, go to the menu at the top of the page and click where it says “Code.” Then, select “Markdown” from the dropdown menu that appears.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/df52ceee-3f35-4214-a032-8f0032e47ea8)

For more information about how to use Markdown, refer to [Markdown guide for basic syntax](https://www.markdownguide.org/basic-syntax/) and the [Markdown guide for extended syntax](https://www.markdownguide.org/extended-syntax/).

## Common actions

Most actions can be performed using both a mouse/graphic interface and keyboard shortcuts. Here are some of the most common actions.

### Add a new cell

- Click on Insert in the menu bar at the top of the notebook. Options are to insert a new cell above or below the current cell.
    
- Keyboard shortcuts (while in command mode):
    
    - **a:** Insert a cell above the current cell
        
    - **b:** Insert a cell below the current cell
        

### Delete a cell

- Use command mode to select a cell or group of cells.
    
- Click on Edit in the menu bar at the top of the notebook and select Delete Cells from the dropdown menu.
    
- Keyboard shortcut (while in command mode): 
    
    - **dd** (press D two times)
        

### Move a cell

- Use command mode to select a cell or group of cells.
    
- Click on the up arrow button or down arrow button in the menu bar at the top of the notebook to move the selected cell(s) up or down 
    

### Run a cell

- Select a cell and click the **Run** button in the menu bar at the top of the notebook.
    
- Keyboard shortcuts:
    
    - **Ctrl + Enter:** Run selected cell
        
    - **Shift + Enter:** Run selected cell and select next cell
        
    - **Alt + Enter:** Run selected cell and insert new cell below
        
- You can run cells from both command mode and edit mode
    

Press **h** while in command mode for a pop-up window with all available keyboard shortcuts. You can also check out [Jupyter Notebook interface components](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html) for more detailed descriptions of various notebook features.

# Troubleshooting

You will use Jupyter notebooks throughout the Advanced Data Analytics certificate program. At times, you might encounter difficulty accessing or running the notebook. Here are some troubleshooting steps to help you if this happens.

## Browser compatibility

Make sure your internet browser is updated regularly. It is best to use the latest version of Google Chrome, Firefox, or Microsoft Edge. If your browser is outdated or you are using a browser that is not supported by Coursera, you may encounter a problem. If your browser is up to date and you are using one of the browsers listed above and still encountering problems, try restarting your browser or clearing your browser’s cache and cookies. You can also use incognito mode, which prevents your browser from storing cookies and other temporary data.

## Internet connection

Coursera requires a stable internet connection. If you are experiencing problems starting or running a Jupyter notebook, your internet connection may be slow or unreliable. Some signs of an unstable internet connection may be pages failing to load, freezing labs, or the inability to type or enter commands within the lab environment. 

**Pro Tip:** If you are unable to complete a lab on one device, try using another device.

## Troubleshooting steps

To summarize, here are the troubleshooting steps to try if you encounter a problem with Jupyter notebooks in Coursera. 

1. Make sure you are using the latest version of a supported browser: Google Chrome, Firefox, or Microsoft Edge.
    
2. Restart your browser and clear your browser’s cache and cookies. You can also use incognito mode.
    
3. Check your internet connection and make sure it is stable. You can try restarting your router and modem to regain a stable connection.
    
4. Try restarting the lab again.
    

If all this fails, it’s possible that Coursera is performing maintenance or experiencing a service interruption. In that case, wait a little while and try again.

# Key takeaways

Jupyter Notebook provides a coding platform where you can develop and debug your own code. Knowing how to use and interact with notebooks will prepare you for upcoming activities where you will try out new Python skills and prepare for the end-of-course project. Python will be a great tool in your toolkit—it will open up more advanced analytics tools like machine learning and automated analysis. And, using Jupyter Notebook will be a great way to build your Python knowledge!

## Resources for more information

- [Jupyter Notebooks interface training](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html)
    
- [Jupyter software homepage](https://jupyter.org/)
    
- [Jupyter documentation](https://docs.jupyter.org/en/latest/)
    
- [Jupyter Notebooks cloud](https://jupyter.org/try-jupyter/retro/notebooks/?path=notebooks/Intro.ipynb) (online)
    
- [Jupyter community forum](https://discourse.jupyter.org/)
    
- [Jupyter notebooks community forum](https://discourse.jupyter.org/c/notebook/3)
    
- [Python community forum](https://www.python.org/community/forums/)
    
- [StackOverflow questions](https://stackoverflow.com/) (crowdsource forum to help solve problems)
    
- [Jupyter Notebooks installation](https://test-jupyter.readthedocs.io/en/latest/install.html)

<br> 

*** 

<br>

# More about object-oriented programming

**Note:** This reading contains only a brief introduction to object-oriented programming. A more detailed discussion about the nuances of object oriented programming is beyond the scope of this course.

Previously, we identified object-oriented programming as a programming paradigm that is based around objects, which can contain both data and code that manipulates that data. You may recall that a class is an object’s data type that bundles data and functionality together, and you’ve encountered some examples of this class-specific functionality in the form of methods and attributes. In this reading, you’re going to learn more about object-oriented programming and how it works. Although this certificate program will not require you to define your own classes, having a basic understanding of how this process works will be very helpful when you encounter these concepts along your learning journey.

## Review: Attributes and methods

Python classes are powerful and convenient because they come with built-in features that simplify common data analysis tasks. These features are known as attributes and methods.

- **Attribute**: A value associated with an object or class which is referenced by name using dot notation.
    
- **Method**: A function that belongs to a class and typically performs an action or operation. 
    

A simpler way of thinking about the distinction between attributes and methods is to remember that attributes are _characteristics_ of the object, while methods are _actions_ or _operations_.

For example, if the class were Spaceship, then attributes might be:

- name

- kind

- speed

- tractor_beam

These attributes could be accessed by typing:

- Spaceship.name

- Spaceship.kind

- Spaceship.speed

- Spaceship.tractor_beam

Notice that these characteristics are accessed using only a dot. 

On the other hand, methods of the Spaceship class might be:

- warp()

- tractor()

These methods could be used by typing:

- Spaceship.warp() 

- Spaceship.tractor()

Notice that methods are followed by parentheses, and it’s possible for them to take arguments. For example, Spaceship.warp(7) could change the speed of the ship to warp seven.

## Defining classes with unique attributes and methods

Python lets you define your own classes, each with their own special attributes and methods. This helps all different kinds of programmers to build reusable code that makes their work more efficient. You can even build the Spaceship class mentioned previously. The example, here, demonstrates how to do this.

**Note:** The following code block is not interactive.

```
   tractor_beam = 'off'

   # Instance attributes

   def __init__(self, name, kind):

       self.name = name

       self.kind = kind

       self.speed = None

  # Instance methods

   def warp(self, warp):

       self.speed = warp

       print(f'Warp {warp}, engage!')

   def tractor(self):

       if self.tractor_beam == 'off':

           self.tractor_beam = 'on'

           print('Tractor beam on.')

       else:

           self.tractor_beam = 'off'

           print('Tractor beam off')
```

For this course you don’t have to learn the syntax to create classes. Just notice that the class itself is defined first, and then indented beneath it are the attributes and methods. This is what it means when an attribute or method “belongs to a class.” Attributes and methods are defined in the code for that class. 

A class is like a blueprint for all things that share characteristics and behaviors. In this case, the class is Spaceship. There can be all different kinds of spaceships. They can have different names and different purposes. Whenever you create an object of a given class, you’re creating an **instance** of that class. This is also known as **instantiating** the class. In the code above, every time you instantiate an object of the Spaceship class it will start with its tractor beam set to off. The tractor beam is a class attribute. All instances of the Spaceship class have one. There are also instance attributes. These are attributes that you can assign when you instantiate the object. 

```
# Create an instance of the Spaceship class (i.e. "instantiate")

ship = Spaceship('Mockingbird','rescue frigate')

# Check ship's name

print(ship.name)

# Check what kind of ship it is

print(ship.kind)

# Check tractor beam status

print(ship.tractor_beam)

# Result

Mockingbird
rescue frigate
off
```

The next block of code uses the warp() method to set the warp speed to seven. Then it checks the current speed of the ship using the speed attribute.

```
# Set warp speed

ship.warp(7)

# Check speed

ship.speed

# Result

Warp 7, engage!
7
```

This final block of code uses the tractor() method to toggle the tractor beam. Then it checks the current status of the tractor beam using the tractor_beam attribute.

```
# Toggle tractor beam

ship.tractor()

# Check tractor beam status

print(ship.tractor_beam)

# Result

Tractor beam on.
on
```

This is just a basic example meant to demonstrate some of the fundamental ways that classes, attributes, and methods work and how they relate to each other, but classes can be very complex and have many attributes and methods. Depending on the work you’re doing as a data professional, knowledge about object-oriented programming will be helpful as you define your own classes, attributes, and methods to investigate the patterns, relationships, and meaning data holds. 

## Key takeaways

Classes comprise the core objects of Python, which is why Python is known as an object-oriented language. Class objects are powerful because they contain unique tools designed specifically for that class packaged within them. Methods are functions that belong to a class; they perform actions or operations, and they use parentheses. Attributes are values or characteristics associated with a class or class instance; they do not use parentheses. And, while there are many classes, attributes, and methods pre-built into Python, there is a high level of customization offered in the object-oriented programming paradigm.

<br> 

*** 

<br>


# Explore Python syntax

Python is a flexible programming language used in a wide range of fields, including software development, machine learning, and data analysis. Python is one of the most popular programming languages for data professionals, so getting familiar with its fundamental syntax and semantics will be useful for your future career. In this reading, you will learn about Python’s syntax and semantics, as well as where to find resources to further your learning.

## The Language of Python

People use language to communicate and give instructions to each other. Computers do the same thing, except computers use languages like Python, C++, and Java. So, in order to communicate instructions to the computer, programmers need to arrange ideas and concepts into a language it will understand.

Python syntax includes words that represent objects and commands, as well as punctuation that gives the words structure, hierarchy, and context. Together, the words and punctuation communicate ideas and processes; this is known as semantics. Semantics is the meaning conveyed by the syntax. The best way to learn syntax and semantics is through exposure. Practice coding and become familiar and comfortable with reading other people’s code. In addition, there are some general conventions that practitioners use to help maintain stylistic uniformity within the language. 

Coding languages are similar to spoken languages in that they have a way to classify words according to their function. For example, English sentences are composed of nouns, verbs, prepositions, etc.

Here are some of the basics:

- **Variables:** Represent data stored as strings, tuples, dictionaries, lists, and objects (note: future readings explain these categories)
    
    - Example: student_name
        
- **Keywords:** Special words that are reserved for specific purposes and that can only be used for those purposes
    
    - Examples:
        
        - in
            
        - not
            
        - or
            
        - for
            
        - while
            
        - return
            
- **Operators:** Symbols that perform operations on objects and values
    
    - Examples:
        
        - + Addition
            
        - - Subtraction
            
        - * Multiplication
            
        - / Division
            
        - ** Exponentiation
            
        - % Modulo (returns the remainder after a division). Example: 10 % 3 = 1
            
        - // Floor division (divides the first operand by the second operand and rounds the result down to the nearest integer. Example: 5 // 2 = 2
            
        - > Greater than (returns a Boolean of whether the left operand is greater than the right operand)
            
        - < Less than (returns a Boolean of whether the left operand is less than the right operand)
            
        - == Equality (returns a Boolean of whether the left operand is equal to the right operand)
            
- **Expressions:** A combination of numbers, symbols, and variables to compute and return a result upon evaluation
    
    - Example: [1, 2, 3] + [2, 4, 6]
        
- **Functions:** A group of related statements to perform a task and return a value
    
    - Example:
        

```
def to_celsius(x):

   '''Convert Fahrenheit to Celsius'''

   return (x-32) * 5/9

to_celsius(75)

# Result

23.88888888888889
```

- **Conditional statements:** Sections of code that direct program execution based on specified conditions
    
    - Example:
        

```
number = -4

if number > 0:

   print('Number is positive.')

elif number == 0:

   print('Number is zero.')

else:

   print('Number is negative.')

# Result

Number is negative.
```

As you’ll surely discover, Python generates syntax errors for incorrectly used keywords and syntax.

Example:

```
print(This will throw an error because I didn’t make it a string.)

# Result

Error on line 1:
    print(This will throw an error because I didn’t make it a string.)
                  ^
SyntaxError: invalid syntax
```

## Naming rules and conventions

When assigning names to objects, programmers adhere to a set of rules and conventions which help to standardize code and make it more accessible to everyone. Here are some naming rules and conventions that you should know:

- Names cannot contain spaces.
    
- Names may be a mixture of upper and lower case characters.
    
- Names can’t start with a number but may contain numbers after the first character.
    
- Variable names and function names should be written in snake_case, which means that all letters are lowercase and words are separated using an underscore. 
    
- Descriptive names are better than cryptic abbreviations because they help other programmers (and you) read and interpret your code. For example, student_name is better than sn. It may feel excessive when you write it, but when you return to your code you’ll find it much easier to understand.
    

Tim Peters, a Python programmer, wrote this now-famous “poem” of guiding principles for coding in Python:

**The Zen of Python**

Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

Special cases aren't special enough to break the rules.

Although practicality beats purity.

Errors should never pass silently.

Unless explicitly silenced.

In the face of ambiguity, refuse the temptation to guess.

There should be one—and preferably only one—obvious way to do it.

Although that way may not be obvious at first unless you're Dutch.

Now is better than never.

Although never is often better than *right* now.

If the implementation is hard to explain, it's a bad idea.

If the implementation is easy to explain, it may be a good idea.

Namespaces are one honking great idea -- let's do more of those!

Finally, it’s helpful to bookmark the [PEP 8 Style Guide for Python](https://peps.python.org/pep-0008/) so you can reference it as needed. This reading is limited in scope, and PEP 8 is a more exhaustive resource for style-related matters. PEP stands for Python Enhancement Proposals. These are a running catalog of ways to improve or standardize Python as a language. Because Python is open source, PEP offers a framework to guide developers and build consensus around ideas. It’s a useful and trusted resource.

## Key takeaways

Syntax and semantics are what give form and meaning to a language, including Python.  A large part of learning a new language is familiarizing yourself with its syntax and semantics. Much of this comes through exposure and practice, but there are a few guiding principles and resources that can help you along the way. If you learn the rules about naming objects and build a bank of resources that you can reference for guidance, you’ll surely make progress as a Python learner. As you get more familiar with Python, you’ll be able to communicate more efficiently with computers and do more with your data analysis tools!

## Resources for more information

Here are a few useful resources to help you get more familiar with Python:

- Python [Reference Library](https://docs.python.org/3/library/)
    
    - [Built-in Data types](https://docs.python.org/3/library/stdtypes.html)
        
    - [Built-in functions](https://docs.python.org/3/library/functions.html#built-in-functions)
        
- [Python operators](https://python-reference.readthedocs.io/en/latest/docs/operators/index.html)

<br> 

*** 

<br>

# Glossary terms from Module 1

# Terms and definitions from Course 2, Module 1

**Argument**: Information given to a function in its parentheses

**Assignment**: The process of storing a value in a variable

**Attribute**: A value associated with an object or class which is referenced by name using dot notation

**Cells**: The modular code input and output fields into which Jupyter Notebooks are partitioned

**Class**: An object’s data type that bundles data and functionality together

**Computer programming**: The process of giving instructions to a computer to perform an action or set of actions

**Data type**: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

**Dot notation**: How to access the methods and attributes that belong to an instance of a class

**Dynamic typing**: Variables that can point to objects of any data type

**Explicit conversion**: The process of converting a data type of an object to a required data type

**Expression**: A combination of numbers, symbols, or other variables that produce a result when evaluated

**Float**: A data type that represents numbers that contain decimals

**Immutable data type**: A data type in which the values can never be altered or updated

**Implicit conversion**: The process Python uses to automatically convert one data type to another without user involvement

**Integer**: A data type used to represent whole numbers without fractions

**Jupyter Notebook**: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

**Keyword**: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

**Markdown**: A markup language that lets the user write formatted text in a coding environment or plain-text editor 

**Method**: A function that belongs to a class and typically performs an action or operation

**Naming conventions**: Consistent guidelines that describe the content, creation date, and version of a file in its name

**Naming restrictions**: Rules built into the syntax of a programming language 

**Object**: An instance of a class; a fundamental building block of Python

**Object-oriented programming**: A programming system that is based around objects which can contain both data and code that manipulates that data

**Programming languages**: The words and symbols used to write instructions for computers to follow

**String**: A sequence of characters and punctuation that contains textual information

**Syntax**: The structure of code words, symbols, placement, and punctuation

**Typecasting:** Converting data from one type to another (see **explicit conversion**)

**Variable**: A named container which stores values in a reserved location in the computer’s memory

<br> 

*** 

<br>

# Module 2 Functions and conditional statements

# Reference guide: Functions

As you’ve been learning, functions are bodies of reusable code for performing specific processes or tasks. They help you do more work with less code. Function examples include: 

- A specific calculation or measurement, such as converting Fahrenheit to Celsius
    
- An inventory utility to iterate quantities and calculate the total cost of goods in stock
    
- Building a DataFrame from a series or dictionary data
    
- An application utility such as a spell checker
    

In this reading, you will learn how to define, build, and call functions. 

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

[Reference guide: Functions](https://docs.google.com/document/d/1Kxm7hv3w6ddQ6C2-m1ZNWD-EWte5QDlF6it0unmLjaw/template/preview?resourcekey=0-BeaGUzArCDKD0NLcRvzSGw) 

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

https://d3c33hcgiwev3.cloudfront.net/J6Hj-0oxSGefqbys50bYOA_55e9f56b4cd24427b1f1fb127c7551f1_Reference-guide_-Functions.docx?Expires=1710288000&Signature=RxpOqchi-7HHCLnPMcNK0wigmSVfP862ELFf~DUjU0TedwJIj6J8Ul0Bpv2y-wYZiLVFqECGLIpvVonXGsHt1VCBzBmz8sxsCicsbsaX51ub~oLMUFC8I0lvPnVazjTPFZ8v~-Ymep8V~3KaZKWtIrAld4g5HrnpYSFJQF~eMDc_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

## Function syntax

Define functions using the following syntax and format:

**Note:** The following code block is not interactive.

```
def my_function(parameters):

    '''

    Docstring.

    Summarize the function's behavior and explain its arguments and return values.

    '''

    code block

    return value
```

1. Begin with the def keyword followed by the function’s name, then put its parameters/arguments in parentheses, ending with a colon.
    
    1. Python convention is to use snake_case (lowercase words separated by underscores) for function names.
        
2. For important functions or functions whose purposes or operations are not very obvious, include a docstring. Write the docstring between three opening and closing quotation marks. 
    
    1. The docstring should be in the form of a command (e.g., “Add two numbers” as opposed to “Adds two numbers”).
        
    2. The docstring should summarize the function’s behavior and explain its arguments and return values.
        
    3. The docstring should be indented four spaces from the definition statement.
        
3. Write the body of the function. 
    
    1. All code should be indented at least four spaces from the definition statement, but there can be many levels of indentation depending on the complexity of the code. 
        
4. Finally, use a return statement to return a value or a print statement to print something to the console and complete the function. This line should also be indented four spaces.
    

## **return vs. print**

Sometimes the difference between return statements and print statements isn’t clear to new learners of Python. It’s important to understand what each action is and when to use it. Return statements give you a result that you can use for something else. It doesn’t have to be something that prints when the function is run. Print statements print something to the console and nothing more. Think of it like this: a return statement is like your brother going to the market and bringing you back a bag of potatoes. A print statement is like your brother going to the market, coming home, and telling you what kind of potatoes were for sale. With the return statement, you have some potatoes to cook. With the print statement, you just know what potatoes are available, but you don’t have any potatoes.

## **Functions vs. methods**

Functions and methods are very similar, but there are a few key differences. Methods are a specific type of function. They are functions that belong to a class. This means that you can use them—or “call” them—by using dot notation. 

**Method example:** 

```
my_string = 'The eagles filled the sky.'

my_string.split()

['The', 'eagles', 'filled', 'the', 'sky.']
```

The split method is a function that belongs to the string class. It splits strings on their whitespaces. 

Standalone functions do not belong to a particular class and can often be used on multiple classes. 

**Note:** The following code block is not interactive.

**Function example:**

```
 sum([6, 3])

9
```

You can review [Python’s list of built-in functions](https://docs.python.org/3/library/functions.html) and research how other people use them in the [Jupyter forum](https://discourse.jupyter.org/), [StackOverflow](https://stackoverflow.com/), and other online communities. 

## Resources for more information

For more information on functions, consider the Python [Reference Library](https://docs.python.org/3/library/), [Data types,](https://docs.python.org/3/library/stdtypes.html) [Functions](https://docs.python.org/3/library/functions.html#built-in-functions), [Symbols](https://wiki.python.org/moin/PythonGlossary?action=AttachFile&do=view&target=PySymbols.html)

- [Built-in functions](https://docs.python.org/3/library/functions.html#built-in-functions): 
    
    - [enumerate](https://docs.python.org/3/library/functions.html#enumerate)()
        
    - [isinstance](https://docs.python.org/3/library/functions.html#isinstance)()
        
    - [dict](https://docs.python.org/3/library/functions.html#func-dict)()
        
    - [type](https://docs.python.org/3/library/functions.html#type)() 
        
    - [len](https://docs.python.org/3/library/functions.html#len)()
        
    - [set](https://docs.python.org/3/library/functions.html#func-set)()
        
    - [zip](https://docs.python.org/3/library/functions.html#zip)()
        
- [Docstring conventions](https://peps.python.org/pep-0257/): PEP 257 guide to writing docstrings


<br> 

*** 

<br>

# Reference guide: Python operators

You’ve encountered many Python operators already. Many of them likely feel very familiar to you. After all, there’s nothing novel about addition and subtraction in Python. But there are many more operators than the ones used for basic arithmetic! Operators are characters that enact specific arithmetic, logical actions, or processes. Data professionals use operators all the time in their work, and they’re a rudimentary part of Python programming, so it’s important to learn them. This reading is a guide to the various operators available to you in Python.  

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Python operators](https://docs.google.com/document/d/1R6CU4cNKvztLqMNCferbGzYMk7KTRv0ZU4eGDlHJ_y8/template/preview)

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/5584Ds17S8OLKxJp_EKing_61b4a59ccbb44525b269496dc43a16f1_Reference-guide_-Python-operators.docx?Expires=1710288000&Signature=NFIDzUQ4pWr7MlBOczJ4SbKcFZ9L7H6fKCCXheBFOxcabir0YBK1gouzf29FoJ1Wrx~euAQH7Zu~FqrOjnOmuAegZcpfLP4iqp6EeAMMiTsztuANCH0ZSN6oRMxIWq9CjKm5f5cQ38EVjTHf2SaGzuPMhoX2P11x26dwyB2tVxg_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Comparators

In Python, you can use comparison operators to compare values. When a comparison is made, Python returns a Boolean result—True or False. Python uses the following comparators:

| **Operation**            | **Operator** |
| ------------------------ | ------------ |
| greater than             | >            |
| greater than or equal to | >=           |
| less than                | <            |
| less than or equal to    | <=           |
| not equal to             | !=           |
| equal to                 | ==           |

**Notes:** 

- The single equals sign (=) is reserved for assignment statements. If you use a single equal sign to make a comparison, the computer will return a **SyntaxError**.
    
- If you try to compare data types that aren’t compatible, like checking if a string is greater than an integer, Python will throw a **TypeError**. 
    

## Logical operators

Python also has three logical operators that can be combined with comparators to create more complex statements.

These operators are:

- and
    
    - evaluates to True only if both statements are true 
        
- or
    
    - evaluates to True if one or both of the statements are true
        
- not
    
    - reverses the evaluation
        
    - If the statement evaluates to True, returns False; if the statement evaluates to False, returns True
        

Examples: 

```
x = 3

my_list = [3, 4, 6, 10]

print(x < 3 and x != 0)

print(x >= len(my_list) or x == min(my_list))

print(x not in my_list)

# Result

False
True
False
```

## Arithmetic operators

Python is also capable of performing mathematical operations using a set of built-in operators. These arithmetic operators are:

|**Operation**|**Operator**|**Example**|
|---|---|---|
|Addition|+|[IN]  5 + 2<br><br>[OUT] 7|
|Subtraction|-|[IN] 5 - 2<br><br>[OUT] 3|
|Multiplication|*|[IN] 5 * 2<br><br>[OUT] 10|
|Division|/|[IN] 5 / 2<br><br>[OUT] 2.5|
|Modulo (the remainder of a division)|%|[IN] 5 % 2 <br><br>[OUT] 1|
|Exponentiation|**|[IN] 5 ** 2<br><br>[OUT] 25|
|Floor division<br><br>(the number of times the denominator can fully go into the numerator)|//|[IN] 5 // 2<br><br>[OUT] 2|

There are many other mathematical operations that can be performed in Python using functions from special libraries, which you’ll learn about later. Python uses a core set of operators to make comparisons, perform logical operations, and compute arithmetic operations. These operators can be combined in statements to perform an infinite number of tasks and operations.

<br> 

*** 

<br>

# Reference guide: Conditional statements

Conditional statements are an essential part of programming. They allow you to control the flow of information based on certain conditions. In Python, if, elif, and else statements are used to implement conditional statements. Using conditional statements to branch program execution is a core part of coding for most data professionals, so it’s important to understand how they work. This reading is a reference guide to conditional statements.

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Conditional statements](https://docs.google.com/document/d/1DnAA9MY1xW-Xw2UrBaAFbHNkkfQxi1ZAYzYazwiCaHo/template/preview?resourcekey=0-nyt9oGjsbubU0Ky8oeff5Q#heading=h.xr97bf74ctnq) 

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/8AjHHn8BQz2FjQJu6_ZseQ_15fb6f2e66ff4f08b2accb3bf3cabbf1_Reference-guide_-Conditional-statements.docx?Expires=1710288000&Signature=ki8i95EbyneewyKLmetrL6xJXKzzfnkJroXcYsLYU8q6u4YjvLAMDd7QgTsTzqXPCDDC~NEkOGeZqYYYd-XmG~4B012B9i~2XVTOKzkOWnrpKVD2qyoT9f0iP43qgg9xt9GWv6jRvaMRDcztfOxK-K3gfZ0KKPJdsSQlqEMfZ5I_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Conditionals syntax

In earlier videos, you learned some built-in Python operators that allow you to compare values, and some logical operators that you can use to combine values. You also learned how to use operators in if-elif-else blocks. 

**Note**: The following code block is not interactive.

The basic syntax of if-elif-else statements in Python is as follows:

```
if condition1:

   # block of code to execute if the condition evaluates to True

elif condition2:

   # block of code to execute if condition1 evaluates to False

   # and condition2 evaluates to True

else:

   # block of code to execute if BOTH condition1 and condition2

   # evaluate to False
```

Here, condition1 and condition2 are expressions that evaluate to either True or False. If the condition in the if statement is true, then the block of code that follows is executed. Otherwise, it is skipped.

The elif statement stands for “else if,” and it is used to specify an alternative condition to check if the first condition is false. You can have any number of elif statements in your code. If the preceding condition is false and the elif condition is true, then the block of code that follows the elif statement is executed.

The else statement is used to specify what code to execute if both the if statement and any subsequent elif statements are false. 

Here is an example that uses all three kinds of statements:

```
x = 8

if x > 5:

   print('x is greater than five')

elif x < 5:

   print('x is less than five')

else:

   print('x is equal to five')

# Result

x is greater than five
```

Some important things to note about conditional statements in Python:

- The elif and else statements are optional. You can have an if statement by itself.
    
- You can have multiple elif statements.
    
- You can only have one else statement, and only at the end of your logic block.
    
- The conditions must be an expression that evaluates to a Boolean value (True or False).
    
- Indentation matters! The code associated with each conditional statement must be indented below it. The typical convention for data professionals is to indent four spaces. Indentation mistakes are one of the most common causes of unexpected code behavior.

<br> 

*** 

<br>

# Glossary terms from module 2

# Terms and definitions from Course 2, Module 2

**Algorithm**: A set of instructions for solving a problem or accomplishing a task

**Boolean**: A data type that has only two possible values, usually true or false

**Branching**: The ability of a program to alter its execution sequence

**Comparator**: An operator that compares two values and produces Boolean values (True/False)

**def**: A keyword that defines a function at the start of the function block

**Docstring**: A string at the beginning of a function’s body that summarizes the function’s behavior and explains its arguments and return values

**elif**: A reserved keyword that executes subsequent conditions when the previous conditions are not true 

**else**: A reserved keyword that executes when preceding conditions evaluate as False

**Function**: A body of reusable code for performing specific processes or tasks

**if**: A reserved keyword that sets up a condition in Python

**Logical operator**: An operator that connects multiple statements together and performs complex comparisons

**Modularity**: The ability to write code in separate components that work together and that can be reused for other programs

**Modulo**: An operator that returns the remainder when one number is divided by another

**Refactoring**: The process of restructuring code while maintaining its original functionality

**return**: A reserved keyword in Python that makes a function produce new results which are saved for later use

**Reusability**: The capability to define code once and using it many times without having to rewrite it

**Self-documenting code**: Code written in a way that is readable and makes its purpose clear

# Terms and definitions from the previous module

## A

**Argument**: Information given to a function in its parentheses

**Assignment**: The process of storing a value in a variable

**Attribute**: A value associated with an object or class which is referenced by name using dot notation

## C

**Cells**: The modular code input and output fields into which Jupyter Notebooks are partitioned

**Class**: An object’s data type that bundles data and functionality together

**Computer programming**: The process of giving instructions to a computer to perform an action or set of actions

## D

**Data type**: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

**Dot notation**: How to access the methods and attributes that belong to an instance of a class

**Dynamic typing**: Variables that can point to objects of any data type

## E

**Explicit conversion**: The process of converting a data type of an object to a required data type

**Expression**: A combination of numbers, symbols, or other variables that produce a result when evaluated

## F

**Float**: A data type that represents numbers that contain decimals

## I

**Immutable data type**: A data type in which the values can never be altered or updated

**Implicit conversion**: The process Python uses to automatically convert one data type to another without user involvement

**Integer**: A data type used to represent whole numbers without fractions

## J

**Jupyter Notebook**: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

## K

**Keyword**: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

## M

**Markdown**: A markup language that lets the user write formatted text in a coding environment or plain-text editor 

**Method**: A function that belongs to a class and typically performs an action or operation

## N

**Naming conventions**: Consistent guidelines that describe the content, creation date, and version of a file in its name

**Naming restrictions**: Rules built into the syntax of the language itself that must be followed

## O

**Object**: An instance of a class; a fundamental building block of Python

**Object-oriented programming**: A programming system that is based around objects which can contain both data and code that manipulates that data

## P

**Programming languages**: The words and symbols used to write instructions for computers to follow

## S

**String**: A sequence of characters and punctuation that contains textual information

**Syntax**: The structure of code words, symbols, placement, and punctuation

## V

**Variable**: A named container which stores values in a reserved location in the computer’s memory

# Module 3 Loops and strings



<br> 

*** 

<br>


# Loops, break, and continue statements

You’ve learned about while loops in Python and have explored some examples. While loops are useful because they allow you to perform an action or evaluation repeatedly until a given condition or requirement is met, and then they stop. This is an important process in computer programming, not just in Python, but in most other languages too. Data professionals use while loops to process data, so it’s important for you to familiarize yourself with them as you grow your skills. This reading is a review of the fundamental concepts of while loops.

## While loop syntax

A while loop is a control structure that allows you to repeatedly execute a block of code for as long as a certain condition is true.

**Note**: The following code block is not interactive.

The basic syntax of a while loop is as follows:

```
while condition:

   # Code block to execute
```

The condition is a Boolean expression that is evaluated at the beginning of each iteration of the loop. If the condition is true, the code block executes. After the code block executes, the condition is evaluated again. This process continues until the condition is false, at which point the loop terminates and the program continues with the next statement after the loop.

Here is an example of a basic while loop:

```
x = 1

while x < 100:

   print(x)

   x = x*2

# Result

1
2
4
8
16
32
64
```

In this example, x equals one when the loop begins. Because x is less than 100, the program prints the value of x, then multiplies x by two. Then the condition is checked again, and because it is still True, the code inside the loop executes again. This process continues until x becomes 128, at which point the condition becomes False and the loop terminates.

## Infinite loops

Be careful with while loops because if you make a mistake with your logic or syntax, it could result in an infinite loop that never terminates. In the previous example, if x = x*2 were accidentally not indented to be in the body of the while loop, the loop would reach the print statement and cycle back to check the conditional statement, which of course would still be true because the value of x would never change from one.

If you get stuck in an infinite loop, don’t worry. You can break out of it by interrupting the kernel. There are several ways to do this:

1. Use the stop button in the menu at the top of the notebook.
    

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/1b394c95-11db-4dad-b461-79099ecde5d9)

2. Go to Kernel in the menu bar at the top of the notebook and select Interrupt from the drop-down menu.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/47221e6a-c528-4f6c-89f4-58004b1a2549)

3. While in command mode, press i twice.

## break & continue

It is possible to end a loop even if the conditional statement is still true. To do this, use a break statement.

Here’s an example:

```
x = 1

i = 0

while x < 100:

   if i == 5:

       break

   print(i, x)

   x = x*2

   i += 1

# Result

0 1
1 2
2 4
3 8
4 16
```

In this example, there is a variable i that acts as a counter. For each iteration of the loop, the program:

1. Checks if x is less than 100.
    
2. If it is, then the program checks if i equals five.
    
3. If it does, the loop terminates because of the break statement. Otherwise, it prints the values of both i and x, doubles the value of x, and increments the value of i by one.
    
4. Repeats until x ≥ 100 or i = 5. In this case, the loop breaks when i becomes 5.
    

It’s also possible to skip an iteration of the loop without executing the rest of the code inside the loop for the current iteration. To do this, use a continue statement.

Here’s an example:

```
i = 0

while i < 10:

    if i % 3 != 0:

        print(i)

        i += 1

        continue

    i += 1

# Result 

1
2
4
5
7
8
```

This example is a loop that prints all the numbers from zero through 9 that are not divisible by three. For each iteration of the loop, the program:

1. Checks if i is less than 10.
    
2. If it is, then the program uses the modulo operator to check if i is evenly divisible by three.
    
3. If it is not, then the program prints i, increments the value of i by one, _and then cycles back to the beginning_ to check that i is less than 10. This happens because of the continue statement. The final i += 1 does not execute, thus avoiding a double incrementation of i.
    
4. But if step 2 evaluates i as evenly divisible by three, nothing in the if block executes (so there’s no print statement) and i is incremented by one.
    
5. Repeats until i becomes 10. 
    

## Key takeaways

A while loop allows you to repeatedly execute a block of code while a certain condition is true. You can use the break statement to exit the loop prematurely, and the continue statement to skip to the next iteration of the loop without executing the rest of the code in the current iteration.

<br> 

*** 

<br>



# For loops

You’ve learned about for loops in Python and have explored some examples. For loops are like while loops, but instead of looping continuously until a condition is met, for loops iterate over each element of an iterable sequence, allowing you to perform an action or evaluation with each iteration. This is an important process in computer programming, not just in Python, but in most other languages too. Data professionals use for loops to process data, so it’s important for you to familiarize yourself with them as you grow your skills. This reading is a review of the fundamental concepts of for loops.

## For loop syntax

A for loop is a control structure that allows you to execute a block of code the same number of times as there are elements in an iterable sequence. You’ll learn more about iterable sequences later in this course, but some examples of iterable data types include:

Strings: ‘chimichurri’

Lists: [1, 2, 3, 4, 5, 6]

Tuples: (1, 2, 3, 4, 5)

Dictionaries: {‘Name’: ‘Anita’, ‘Age’: 77} 

Sets: {1, 4, 14, 33}

**Note**: The following code block is not interactive.

The basic syntax of a for loop is as follows:

```
for item in iterable_sequence:

   # Code block to be executed for each value in iterable_sequence
```

The iterable_sequence variable can be any iterable data type, and item is a variable whose name is arbitrary —you decide it. However, there are some conventions that you’ll encounter when naming this variable. For example, if you’re iterating over characters in a string, you’ll frequently encounter the variable char. If you’re iterating over a list of numbers, you’ll find n or num. It’s helpful to give this variable a name so readers of your code understand what kind of information is being looped over. So, for a variable called names that contains a list of people’s names, you might write: for name in names:.

A note about the behavior of this variable — its value is reassigned for each iteration of the loop, and it persists even after the loop terminates.

Here’s an example:

```
num = 5

y = [1, 2, 3]

for num in y:

   print(num)

print(num)

# Result 

1
2
3
3
```

Notice that num exists as a variable before the for loop begins. The for loop’s first iteration reassigns its value with that of the first element in the sequence. This reassignment occurs with each iteration of the loop. When the loop terminates, the variable persists, and it contains the value it had after the final iteration of the loop.

## The range() function

The for loop allows you to create a loop that performs exactly the number of iterations needed for the data structure you’re looping over. In other words, whether your iterable sequence contains two, 1,000, or a million elements, you can use the same syntax and don’t have to specify the number of iterations you want. However, sometimes you need to perform a task a set number of times, but you don’t already have an iterable object to loop over. Or, sometimes you need to generate a known, regular sequence of numbers. This is where the range() function is useful.

The range() function is a function that takes three arguments: start, stop, step. Its output is an object belonging to the range class. If you only include one argument, it will be interpreted as the stop value. The start and step values by default will be zero and one, respectively. If you include two arguments, they will be interpreted as the start and stop values (again, with step being one by default). Note that the stop value is not included in the range that is returned.

Here are some examples:

**A.**

```
for i in range(3):

   print(i)

# Result

0
1
2
```

**B.**

```
for n in range(2, 5):

   print(n)

# Result

2
3
4
```

**C.**

```
for even_num in range(2, 11, 2):

   print(even_num)

# Result

2
4
6
8
10
```

You’ll find that the range() function is very useful, for example, when creating numbered lists or performing operations on certain indices of an object. You’ll learn more about indexing later.

## Nested loops

Sometimes you’ll need to extract information from nested structures—for example, from a list of lists. One way of doing this is by using nested loops. A nested loop is a loop inside of another loop. You can have an infinite number of nested loops, but it becomes more confusing to read and understand the more nested loops you add.

Here’s an example of one loop nested in another:

```
students = [['Igor', 'Sokolov'], ['Riko', 'Miyazaki'], ['Tuva', 'Johansen']]

for student in students:

   for name in student:

       print(name)

   print()

# Result

Igor
Sokolov

Riko
Miyazaki

Tuva
Johansen
```

In this example, the students variable contains a list of three lists. Each inner list contains two elements: a given name and a surname. The first for loop iterates over the inner lists. The second (nested) for loop iterates over each name in each inner list and prints the name. After each iteration of the outer loop, the program uses an empty print statement to print a new line.

## Key takeaways

A for loop allows you to execute a block of code the same number of times as there are elements in an iterable sequence. The range() function is useful for creating a defined iterable sequence. And nested loops are loops within loops that give you even greater power and control over how your code may execute. These are powerful tools that can be used in many different ways to solve a variety of problems that you’ll encounter as a data professional.


<br> 

*** 

<br>




# String indexing and slicing

As you know, strings are an important class of data because they represent text. Data professionals encounter strings all the time, so it’s important to become familiar with different ways of manipulating and working with them. This reading will review the string formatting techniques you’ve learned and also introduce you to regular expressions.

## String formatting

Indexing refers to accessing a single element of a sequence by its position. _In Python, the first element of any sequence has an_ **index of zero.** This means Python uses zero-based indexing. Numerous other programming languages also use zero-based indexing, but not all of them do. Some languages use one-based indexing, such as R, Julia, and SAS. 

Use square brackets to perform indexing. Here are some examples:

```
my_string = 'Mississippi half-step'

print(my_string[0])

my_list = [1, 'unladen', 'swallow']

print(my_list[1])

print(my_list[-1])

# Result

M
unladen
swallow
```

In these examples, there are two sequence variables: a string and a list. Indexing is used to access the character at index zero of the string, which is its first character—M. The list is selected at index one, which contains the word “unladen.” The list is also selected at its final position using negative indexing. 

**Note:** If you try to select an index that is out of range of what the object contains, you’ll get an IndexError. 

```
my_list = [1, 'unladen', 'swallow']

my_list[3]

# Result

Error on line 2:
    my_list[3]
IndexError: list index out of range
```

## Slicing

Slicing refers to accessing a range of elements from a sequence. Use square brackets containing two indices separated by a colon.

Here are some examples:

```
new_string = 'pining for the fjords'

print(new_string[0:3])

print(new_string[:3])

# Result

pin
pin
```

These two examples, each with slightly different syntax, are being used to produce the same result. Notice two things: (1) the resulting slice includes the starting index and excludes the ending index; (2) when the starting index is omitted it’s implied to be zero, as shown in the second print line. 

The process follows the same logic when the ending index is omitted:

```
new_string = 'pining for the fjords'

print(new_string[6:21])

print(new_string[6:])

print(len(new_string))

# Result

 for the fjords
 for the fjords
21
```

Again, there are two statements that are syntactically different but still produce the same substring. When the ending index is omitted, its implied value is the length of the sequence.  

Finally, the code will throw an IndexError if you try to index a sequence at an index number outside the scope of the elements; this is not the case for slicing.

For example:

```
new_string = 'pining for the fjords'

print(new_string[6:100])

# Result

 for the fjords
```

Although the ending index was 100—far beyond the scope of the indices in the string—the computer returned a substring that ended with the string’s final element. 

## Key takeaways

Indexing and slicing are powerful tools in Python that allow you to access specific elements or parts of a sequence. Both indexing and slicing use square brackets. Remember that in a slice the starting index is inclusive and the stopping index is exclusive, and that negative indices count from the end of the sequence. With these tools, you can manipulate strings and other iterable sequences to perform a wide variety of operations, making you a more proficient data professional.

<br> 

*** 

<br>



# String formatting and regular expressions

As you’ve learned, strings are a crucial class of data because they represent textual information. Data professionals encounter strings all the time, so it’s important to become familiar with different ways of manipulating and working with them. This reading will review the string formatting techniques you’ve learned, and also introduce you to regular expressions. 

## String formatting

String formatting uses the format() method, which belongs to the string class. This method formats and inserts specific substrings into designated places within a larger string. It’s useful when you have reusable template text into which you want to insert specific changeable values, for example. The format() method is also useful when assigning the strings used to label charts and graphs you make.

Here’s an example:

```
x = 'values'

y = 100

print('''String formatting lets you insert {} into strings.

They can even be numbers, like {}.'''.format(x, y))

Reset

String formatting lets you insert values into strings.
They can even be numbers, like 100.
```

Notice the syntax. The format() function inserts its arguments into the braces within the string that it’s attached to. The order of insertion follows the order of the arguments. Also, this example includes a helpful trick. Sometimes you’ll encounter a very long string. Many editors will allow the string to keep extending to the right on a single line. This is impractical unless you have a very wide monitor, but 79 characters is a conventional maximum length for a single line of Python code. Enclosing your string in triple quotes lets you break the string over multiple lines.

The format() function can also insert values into braces using explicitly assigned keyword names, which allow you to mix up the order of the function’s arguments without changing the order of their insertion into the final string.

For example:

```
var_a = 'A'

var_b = 'B'

print('{a}, {b}'.format(b=var_b, a=var_a))

Reset

A, B
```

Because the arguments were named, it didn’t matter that they were entered with var_b first and var_a last; they still were inserted into the string in the order specified.

You can also include the arguments’ index numbers within the braces to indicate which arguments get inserted in specific spots:

```
var_a = 'A'

var_b = 'B'

print('{1}, {0}'.format(var_a, var_b))

print('{0}, {1}'.format(var_a, var_b))

Reset

B, A
A, B
```

You can have as many arguments as you want:

```
print('{}, {}, {}, {}, {}, {} ...'.format(1, 2, 3, 4, 5, 6))

Reset

1, 2, 3, 4, 5, 6 ...
```

And you can repeat arguments’ indices:

```
print('{0}{1}{0}'.format('abra', 'cad'))
```

Reset

abracadabra

The string format() method is a versatile and convenient way to take values that are stored in different variables and insert them into a string.

## **Literal string interpolation (f-strings)**

Another string formatting technique that you’ll often encounter when using Python version 3.6+ is literal string interpolation, also known as f-strings. F-strings further minimize the syntax required to embed expressions into strings. They’re called f-strings because the expressions always begin with f (or F—they’re the same).

For example:

```
var_a = 1

var_b = 2

print(f'{var_a} + {var_b}')

print(f'{var_a + var_b}')

print(f'var_a = {var_a} \nvar_b = {var_b}')

Reset

1 + 2
3
var_a = 1 
var_b = 2
```

In these examples, the braces still function as the way to indicate where values should be inserted into the string, but they allow you to make the insertion directly, without having to call the format() method.

## **Float formatting options**

In addition to inserting expressions into strings, string formatting can format their appearance. There are too many options to list here, but the [Python string documentation](https://docs.python.org/3/library/string.html) is a good place to review these techniques. Here are some of the most useful.

### **To use these options, build your expression within braces as follows.**

1. The float variable is what’s being formatted
    
2. A colon (:) separates what’s being formatted from the syntax used to format it
    
3. . number indicates the desired precision
    
4. A letter indicates the presentation type
    

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/02a8ed3b-fd9d-4804-9d94-08daf6759e11)

Example:

```
num = 1000.987123

f'{num:.2f}'

Reset

1000.99
```

This example uses the f presentation type to specify that the number contained in the num variable should be rounded to two places beyond the decimal.

Here are some of the most common presentation types:

|**Type**|**Meaning**|
|---|---|
|'e'|Scientific notation. For a given precision p, formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, e uses a precision of 6 digits after the decimal point for [float](https://docs.python.org/3/library/functions.html#float), and shows all coefficient digits for [decimal](https://docs.python.org/3/library/decimal.html#decimal.Decimal).|
|'f'|Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point.|
|'%'|Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign.|

Here are some examples:

```
num = 1000.987123

print(f'{num:.3e}')

decimal = 0.2497856

print(f'{decimal:.4%}')

Reset

1.001e+03
24.9786%
```

## **String methods**

As one of the primary object classes in Python, strings have many built-in methods designed to facilitate working with them. There are too many of these methods to cover all of them here in depth, but some of the most useful include:

str.count(sub[, start[, end]])

Return the number of non-overlapping occurrences of substring sub in the range [start , end].

```
my_string = 'Happy birthday'

print(my_string.count('y'))

print(my_string.count('y', 2, 7))

Reset

2
1
```

### str.find(sub)

Return the lowest index in the string where substring sub is found. Return -1 if sub is not found.

```
my_string = 'Happy birthday'

my_string.find('birth')

Reset

6
```

### str.join()

Return a string which is the concatenation of the strings in iterable. The separator between elements is the string providing this method.

```
separator_string = ' '

iterable_of_strings = ['Happy', 'birthday', 'to', 'you']

separator_string.join(iterable_of_strings)

Reset

Happy birthday to you
```

### str.partition(sep)

Split the string at the first occurrence of sep , and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.

```
my_string = 'https://www.google.com/'

my_string.partition('.')

Reset

('https://www', '.', 'google.com/')
```

### str.replace(old, new[, count])

Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.

```
my_string = 'https://www.google.com/'

my_string.replace('google', 'youtube')

Reset

https://www.youtube.com/
```

### str.split([sep])

Return a list of the words in the string, using sep (optional) as the delimiter string. If no sep is given, whitespace characters are used as the delimiter. Any number of consecutive whitespaces would indicate a split point, so ' ' (a single whitespace) would split the same way as ' ' (two or more whitespaces).

```
my_string = 'Do you know the muffin man?'

my_string.split()

Reset

['Do', 'you', 'know', 'the', 'muffin', 'man?']
```

Note that some of these methods have additional optional parameters. This reading covers only the most rudimentary ones. Reference the full [string methods documentation](https://docs.python.org/2/library/stdtypes.html#string-methods) for more information on these functions and other methods not included here.

## Regular expressions

Regular expressions, also known as regex, refer to techniques that advanced data professionals use to modify and process string data. This certificate program will not require you to use regular expressions in your work, but it’s important for you to be aware of the concept. As always, you’re encouraged to explore regular expressions on your own. 

Regex works by matching patterns in Python. It allows you to search for specific patterns of text within a string of text. Regex is used extensively in web scraping, text processing and cleaning, and data analysis. 

The first step in working with regular expressions is to import the re module. This module provides the tools necessary for working with regular expressions. Once you have imported the module, you can start working with regular expressions.

**Note**: The following code block is not interactive.

The basic syntax for a regular expression is:

```
import re

pattern = 'regex_pattern'

match = re.search(pattern, string)
```

Here is a basic example:

```
import re

my_string = 'Three sad tigers swallowed wheat in a wheat field'

re.search('wall', my_string)

Reset

<_sre.SRE_Match object; span=(18, 22), match='wall'>
```

This example returns a match object that contains information about the search. In this case, it tells you that the substring ‘wall’ does occur in the string from indices 18–22. 

Regex is especially useful because it allows you a very high degree of customization when performing your searches.

Here’s another example:

```
import re

my_string = 'Three sad tigers swallowed wheat in a wheat field'

re.search('[bms]ad', my_string)

Reset

<_sre.SRE_Match object; span=(6, 9), match='sad'>
```

This example will search for “bad,” “mad,” and “sad.” Again, these are very basic examples.

Regex has a large catalogue of special expressions that let you search for substrings that will only match if, for example, they are followed by certain characters, or if they don’t contain a certain set of characters. It can get very complex. Depending on the work you do as a data professional, you may find yourself exploring regular expressions to analyze and process your data.

## Key takeaways

String formatting is the process of inserting specific substrings into designated places within a larger string. Often, the inserted substrings get processed and formatted a certain way. There are multiple ways of using string formatting to help you process strings. These include the format() method, literal string interpolations—or f-strings—and regular expressions, also known as regex. The methods you use will depend on what your data demands and your own personal preferences, but it’s important to be familiar with the most common techniques used by data professionals.

# Glossary terms from module 3

# Terms and definitions from Course 2, Module 3

break: A keyword that lets a user escape a loop without triggering any ELSE statement that follows it in the loop

Concatenate: To link or join together

Escape character: A character that changes the typical behavior of the characters that follow it

For loop: A piece of code that iterates over a sequence of values

format(): A string method that formats and inserts specific substrings into designated places within a larger string

index(): A string method that outputs the index number of a character in a string

Indexing: A way to refer to the individual items within an iterable by their relative position

Iterable: An object that’s looped, or iterated, over

Iteration: The repeated execution of a set of statements, where one iteration is the single execution of a block of code

Loop: A block of code used to carry out iterations 

range(): A Python function that returns a sequence of numbers starting from zero, increments by 1 by default, and stops before the given number 

String slice: A portion of a string that can contain more than one character; also referred to as a substring 

While loop: A loop that instructs the computer to continuously execute the code based on the value of a condition

Terms and definitions from previous modules

A

Algorithm: A set of instructions for solving a problem or accomplishing a task

Argument: Information given to a function in its parentheses

Assignment: The process of storing a value in a variable

Attribute: A value associated with an object or class which is referenced by name using dot notation

B

Boolean: A data type that has only two possible values, usually true or false

Branching: The ability of a program to alter its execution sequence

C

Cells: The modular code input and output fields into which Jupyter Notebooks are partitioned

Class: An object’s data type that bundles data and functionality together

Comparator: An operator that compares two values and produces Boolean values (True/False)

Computer programming: The process of giving instructions to a computer to perform an action or set of actions

D

Data type: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

def: A keyword that defines a function at the start of the function block

Docstring: A string at the beginning of a function’s body that summarizes the function’s behavior and explains its arguments and return values

Dot notation: How to access the methods and attributes that belong to an instance of a class

Dynamic typing: Variables that can point to objects of any data type

E

elif: A reserved keyword that executes subsequent conditions when the previous conditions are not true 

else: A reserved keyword that executes when preceding conditions evaluate as False

Explicit conversion: The process of converting a data type of an object to a required data type

Expression: A combination of numbers, symbols, or other variables that produce a result when evaluated

F

Float: A data type that represents numbers that contain decimals

Function: A body of reusable code for performing specific processes or tasks

I

if: A reserved keyword that sets up a condition in Python

Immutable data type: A data type in which the values can never be altered or updated

Implicit conversion: The process Python uses to automatically convert one data type to another without user involvement

Integer: A data type used to represent whole numbers without fractions

J

Jupyter Notebook: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

K

Keyword: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

L

Logical operator: An operator that connects multiple statements together and performs complex comparisons

M

Markdown: A markup language that lets a user write formatted text in a coding environment or plain-text editor 

Method: A function that belongs to a class and typically performs an action or operation

Modularity: The ability to write code in separate components that work together and that can be reused for other programs

Modulo: An operator that returns the remainder when one number is divided by another

N

Naming conventions: Consistent guidelines that describe the content, creation date, and version of a file in its name

Naming restrictions: Rules built into the syntax of a programming language 

O

Object: An instance of a class; a fundamental building block of Python

Object-oriented programming: A programming system that is based around objects which can contain both data and code that manipulates that data

P

Programming languages: The words and symbols used to write instructions for computers to follow

R

Refactoring: The process of restructuring code while maintaining its original functionality

return: A reserved keyword in Python that makes a function produce new results which are saved for later use

Reusability: The capability to define code once and using it many times without having to rewrite it

S

Self-documenting code: Code written in a way that is readable and makes its purpose clear

String: A sequence of characters and punctuation that contains textual information

Syntax: The structure of code words, symbols, placement, and punctuation

V

Variable: A named container which stores values in a reserved location in the computer’s memory

# Module 4 Data structures in Python

<br> 

*** 

<br>



# Reference guide: Lists

You’ve been learning that lists are important data structures in Python. A list is a data structure that helps store and manipulate an ordered collection of items. These items can be of any data type such as integers, floats, strings, and even other lists. Because they are so versatile, data professionals and all Python programmers use lists every day, so it’s important to be familiar with how they work. This reading is a reference guide for lists designed to help you as you learn Python.

## **Save this course item**

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Lists](https://docs.google.com/document/d/1yZoljX91vuOG2dXAekx0lf3w1DxX1z1NyMtcUSdYEzQ/template/preview#heading=h.387z4nt1u8b3)

OR

If you don’t have a Google account, you can download the item directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/EQNOVNiJRyqtZY1tk0mulQ_cf32c9e13cc0478db1b344c7fe927df1_Reference-guide_-Lists.docx?Expires=1710374400&Signature=WaJDrrIENowD87Zbhx2EyRieMBRVxrA0ZOdpoDn~MQf74hvwmXJ7dI860BMbeWQCzfz1XeRud4k9P2Ff6jDttynEckgy-n5rVEznj8VWoxoMZbRScQkepHx4gZYN8a7xo-YtaBVblG5gDIg01KqAIclYDQ0~pqR5ZTVuKWnJ~ms_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Create a list

There are two main ways to create lists in Python:

- Square brackets: []
    
- The list function: list()
    

When instantiating a list using brackets, separate each element with a comma.

For example, the following code creates a list of strings:

```
list_a = ['olive', 'palm', 'coconut']

print(list_a)

Reset

['olive', 'palm', 'coconut']
```

You can also create a list of integers:

```
list_b = [8, 6, 7, 5, 3, 0, 8]

print(list_b)

Reset

[8, 6, 7, 5, 3, 0, 8]
```

Or a list of mixed data types:

```
list_c = ['Abidjan', 14.2, [1, 2, None], 'Zagreb']

print(list_c)

Reset

['Abidjan', 14.2, [1, 2, None], 'Zagreb']
```

To create an empty list, use empty brackets or the list() function:

```
empty_list_1 = []

empty_list_2 = list()

Reset

[]
```

## Indexing and slicing

Just as with strings, you can access elements in a list using indexing and slicing. The first element of a list has index zero, the second element has index one, and so on. Use square brackets to index:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[1])

Reset

inclinant
```

You can also use negative indices to access items from the end of a list:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[-1])

Reset

obligant
```

Use slicing to extract a sublist. To slice, use square brackets containing a range of indices separated by a colon:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[1:4])

Reset

['inclinant', 'sed', 'non']
```

Notice that this code returned a sublist containing the elements at indices one, two, and three of phrase. The ending index of the slice is not included.

Omitting the starting index in a slice implies an index of zero, and omitting the ending index implies an index of len(my_list):

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[:3])

print(phrase[3:])

Reset

['Astra', 'inclinant', 'sed']
['non', 'obligant']
```

## List mutability

Lists are mutable, which means that you can change their contents after they are created. You can change an individual item in a list by specifying its index and assigning a new value to it. For example:

```
my_list = ['Macduff', 'Malcolm', 'Duncan', 'Banquo']

my_list[2] = 'Macbeth'

print(my_list)

Reset

['Macduff', 'Malcolm', 'Macbeth', 'Banquo']
```

You can even change a slice of a list using the same logic. The slice can be of any length. The elements in the new list will be inserted in place of the indicated slice: 

```
my_list = ['Macduff', 'Malcolm', 'Macbeth', 'Banquo']

my_list[1:3] = [1, 2, 3, 4]

print(my_list)

Reset

['Macduff', 1, 2, 3, 4, 'Banquo']
```

## List operations

Lists can be combined using the addition operator (+):

```
num_list = [1, 2, 3]

char_list = ['a', 'b', 'c']

num_list + char_list

Reset

[1, 2, 3, 'a', 'b', 'c']
```

They can also be multiplied using the multiplication operator (*):

```
list_a = ['a', 'b', 'c']

list_a * 2

Reset

['a', 'b', 'c', 'a', 'b', 'c']
```

But they cannot be subtracted or divided. 

You can check whether a value is contained in a list by using the in operator:

```
num_list = [2, 4, 6]

print(5 in num_list)

print(5 not in num_list)

Reset

False
True
```

## List methods

Lists are a core Python class. As you’ve learned, classes package data together with tools to work with it. Methods are functions that belong to a class. Lists have a number of built-in methods that are very useful.

## append()

Add an element to the end of a list:

```
my_list = [0, 1, 1, 2, 3]

variable = 5

my_list.append(variable)

print(my_list)

Reset

[0, 1, 1, 2, 3, 5]
```

## insert()

Insert an element at a given position:

```
my_list = ['a', 'b', 'd']

my_list.insert(2, 'c')

print(my_list)

Reset

['a', 'b', 'c', 'd']
```

## remove()

Remove the first occurrence of an item:

```
my_list = ['a', 'b', 'd', 'a']

my_list.remove('a')

print(my_list)

Reset

['b', 'd', 'a']
```

## pop()

Remove the item at the given position in the list, and return it. If no index is specified, pop() removes and returns the last item in the list:

```
my_list = ['a', 'b', 'c']

print(my_list.pop())

print(my_list)

Reset

c
['a', 'b']
```

## clear()

Remove all items:

```
my_list = ['a', 'b', 'c']

my_list.clear()

print(my_list)

Reset

[]
```

## index()

Return the index of the first occurrence of an item in the list:

```
my_list = ['a', 'b', 'c', 'a']

my_list.index('a')

Reset

0
```

## count()

Return the number of times an item occurs in the list:

```
my_list = ['a', 'b', 'c', 'a']

my_list.count('a')

Reset

2
```

## sort()

Sorts the list ascending by default. You can also make a function to decide the sorting criteria:

```
char_list = ['b', 'c', 'a']

num_list = [2, 3, 1]

char_list.sort()

num_list.sort(reverse=True)

print(char_list)

print(num_list)

Reset

['a', 'b', 'c']
[3, 2, 1]
```

## **Additional resources**

- For more information about lists, refer to [An Informal Introduction to Python: Lists](https://docs.python.org/3/tutorial/introduction.html#lists).
    
- For more list methods, refer to [Data Structures: More on Lists](https://docs.python.org/3/tutorial/datastructures.html).

<br> 

*** 

<br>



# Compare lists, strings, and tuples

You’ve now learned about some of Python’s core iterable sequence data structures, including strings, lists, and tuples. These structures share many similarities, but there are some key differences between them. Data professionals must often decide which data structures work best to solve a particular problem, so understanding the relationship between these classes can help you make informed decisions in your work. This reading is a guide to the similarities and differences between strings, lists, and tuples.

## Strings

### **Syntax/instantiation**

**Note**: The following code block is not interactive.

- Single, double, or triple quotes:
    

```
empty_str = ''

my_string1 = 'minerals'

my_string2 = "martin"

my_string3 = """

marathon

golfcart

"""
```

**Note**: Using triple quotes to write a string over multiple lines will insert newlines (\n).


```
my_string3 = """

marathon

golfcart

"""

my_string3

Reset

marathon
golfcart
```

- The str() function can be used for instantiation and conversion.
    

**Note**: The following code block is not interactive.

```
 empty_str = str()

my_string = str(125)
```

### **Content**

- Strings can contain any character—letters, numbers, punctuation marks, spaces—but everything between the opening and closing quotation marks is part of the same single string. 
    

### **Mutability**

- Strings are **immutable**. This means that once a string is created, it cannot be modified. Any operation that appears to modify a string actually creates a new string object.
    

### **Usage**

- Strings are most commonly used to represent text data.
    

### **Methods**

The Python string class comes packed with many useful methods to manipulate the data contained in strings. For more information on these methods, refer to [Common String Operations](https://docs.python.org/3/library/string.html) in the Python documentation.

## Lists

### **Syntax/instantiation**

- Brackets, with each element separated by a comma:
    

**Note**: The following code block is not interactive.

```
empty_list = []

my_list = [1, 2, 3, 4, 5]
```

- The list() function can be used for instantiation and conversion. Note that this function only works on iterable data types.
    

```
print(list('rocks'))

print(list(('stones', 'water', 'underground')))

Reset

['r', 'o', 'c', 'k', 's']
['stones', 'water', 'underground']
```

### **Content** 

- Lists can contain any data type, and in any combination. So, a single list can contain strings, integers, floats, tuples, dictionaries, and other lists.
    

**Note**: The following code block is not interactive.

```
my_list = [1, 2, 1, 2, 'And through', ['and', 'through']]
```

### **Mutability**

- Lists are **mutable**. This means that they can be modified after they are created.
    

```
num_list = [1, 2, 3]

num_list[0] = 5446

print(num_list)

Reset

[5446, 2, 3]
```

### **Usage**

- Lists are very versatile and therefore are used in numerous cases. Some common ones are:
    
    - Storing collections of related items
        
    - Storing collections of items that you want to iterate over: Because lists are ordered, you can easily iterate over their elements using a for loop or list comprehension.
        
    - Sorting and searching: Lists can be sorted and searched, making them useful for tasks such as finding the minimum or maximum value in a list or sorting a list of items alphabetically.
        
    - Modifying existing data: Because lists are mutable, they are useful for situations in which you know you’ll need to modify your data.
        
    - Storing results: Lists can be used to store the results of a computation or a series of operations, making them useful in many different programming tasks.
        

### **Methods**

- You can find methods for the Python list class in [More on Lists](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) in the Python documentation.
    

## **Tuples**

### **Syntax/instantiation**

- Parentheses, with each element separated by a comma:
    

**Note**: The following code block is not interactive.

```
empty_tuple = ()

my_tuple = (1, 'z')
```

**Note:** When using parentheses to declare a tuple with just a single element, you must use a trailing comma.

```
test1 = (1)

test2 = (2,)

print(type(test1))

print(type(test2))

Reset

<class 'int'>
<class 'tuple'>
```

- No parentheses, but each element followed by a comma (even if there’s only one element):
    

```
tuple1 = 1,

tuple2 = 2, 3

print(type(tuple1))

print(type(tuple2))

Reset

<class 'tuple'>
<class 'tuple'>
```

- The tuple() function can be used for instantiation, and for conversion of iterable data types.
    

**Note**: The following code block is not interactive.

```
empty_tuple = tuple()

my_tuple = tuple([1, 'z'])
```

### **Content** 

- Tuples can contain any data type, and in any combination. So, a single tuple can contain strings, integers, floats, lists, dictionaries, and other tuples.
    

**Note**: The following code block is not interactive.

```
my_tuple = (1871, 'all', 'mimsy', ('were', 'the'), ['borogroves'])
```

### **Mutability**

- Tuples are **immutable**. This means that once a tuple is created, it cannot be modified. 
    

### **Usage**

- Common uses of tuples include:
    
    - Returning multiple values from a function
        
    - Packing and unpacking sequences: You can use tuples to assign multiple values in a single line of code.
        
    - Dictionary keys: Because tuples are immutable, they can be used as dictionary keys, whereas lists cannot. (You’ll learn more about dictionaries later.)
        
    - Data integrity: Due to their immutable nature, tuples are a more secure way of storing data because they safeguard against accidental changes.
        

### **Methods**

- Because tuples are built for data security, Python has only two methods that can be used on them:
    
    - count() returns the number of times a specified value occurs in the tuple.
        
    - index() searches the tuple for a specified value and returns the index of the first occurrence of the value.
        

## Key takeaways

Strings, lists, and tuples are all iterable sequential data structures that share many similarities. They also have fundamental differences that you should be aware of so you can make effective choices in your work as a data professional. When selecting a data structure, consider its manner of instantiation, content, mutability, and the use case.

## Resources:

- For more information about strings, refer to the [Introduction to Python strings documentation](https://docs.python.org/3/tutorial/introduction.html#strings).
    
- For more information about lists, refer to the [Introduction to Python lists documentation](https://docs.python.org/3/tutorial/introduction.html#lists).
    
- For more information about tuples, refer to the [Python Standard Data Types tuples documentation](https://docs.python.org/3/library/stdtypes.html#tuples).

<br> 

*** 

<br>

# zip(), enumerate(), and list comprehension

You’ve learned much about iterable objects such as strings, lists, and tuples, and soon you’ll learn more. These objects comprise many of Python’s core data structures and, as a data professional, you’ll work with them constantly. While working in Python, you’ll often need to perform the same tasks and operations many times. This reading will introduce you to three time-saving tools: zip(), enumerate(), and list comprehension.

## **zip()**

The [zip() function](https://docs.python.org/3/library/functions.html#zip) is a built-in Python function that does what the name implies: It performs an element-wise combination of sequences. 

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/582d787d-e8b8-4a3b-b6a9-919c22a10d05)

The function returns an **iterator** that produces tuples containing elements from each of the input sequences. An iterator is an object that enables processing of a collection of items one at a time without needing to assemble the entire collection at once. Use an iterator with loops or other iterable functions such as list() or tuple(). Here’s an example:

```
cities = ['Paris', 'Lagos', 'Mumbai']

countries = ['France', 'Nigeria', 'India']

places = zip(cities, countries)

print(places)

print(list(places))

Reset

<zip object at 0x7f72d01d28c8>
[('Paris', 'France'), ('Lagos', 'Nigeria'), ('Mumbai', 'India')]
```

Notice that, in this case, the list() function is used to generate a list of tuples from the iterator object. Here are a few things to keep in mind when using the zip() function.

- It works with two or more iterable objects. The given example zips two sequences, but the zip() function will accept more sequences and apply the same logic. 
    
- If the input objects are of unequal length, the resulting iterator will be the same length as the shortest input.
    
- If you give it only one iterable object as an argument, the function will return an iterator that produces tuples containing only one element from that iterable at a time. 
    

### Unzipping

You can also unzip an object with the * operator. Here’s the syntax:

```
scientists = [('Nikola', 'Tesla'), ('Charles', 'Darwin'), ('Marie', 'Curie')]

given_names, surnames = zip(*scientists)

print(given_names)

print(surnames)

Reset

('Nikola', 'Charles', 'Marie')
('Tesla', 'Darwin', 'Curie')
```

Note that this operation unpacks the tuples in the original list element-wise into two tuples, thus separating the data into different variables that can be manipulated further.

enumerate() 

The [enumerate() function](https://docs.python.org/3/library/functions.html#enumerate) is another built-in Python function that allows you to iterate over a sequence while keeping track of each element’s index. Similar to zip(), it returns an iterator that produces pairs of indices and elements. Here’s an example:

```
letters = ['a', 'b', 'c']

for index, letter in enumerate(letters):

   print(index, letter)

Reset

0 a
1 b
2 c
```

Note that the default starting index is zero, but you can assign it to whatever you want when you call the enumerate() function. For example:

```
letters = ['a', 'b', 'c']

for index, letter in enumerate(letters, 2):

   print(index, letter)

Reset

2 a
3 b
4 c
```

In this case, the number two was passed as an argument to the function, and the first element of the resulting iterator had an index of two. The enumerate() function is useful when an element’s place in a sequence must be used to determine how the element should be handled in an operation.

## **List comprehension**

One of the most useful tools in Python is [list comprehension](https://docs.python.org/3/tutorial/datastructures.html?highlight=list%20comprehension#list-comprehensions). List comprehension is a concise and efficient way to create a new list based on the values in an existing iterable object. List comprehensions take the following form:

my_list = [expression for element in iterable if condition]

In this syntax:

- expression refers to an operation or what you want to do with each element in the iterable sequence.
    
- element is the variable name that you assign to represent each item in the iterable sequence.
    
- iterable is the iterable sequence.
    
- condition is any expression that evaluates to True or False. This element is optional and is used to filter elements of the iterable sequence.
    

Here are some examples of list comprehensions:

This list comprehension adds 10 to each number in the list:

```
numbers = [1, 2, 3, 4, 5]

new_list = [x + 10 for x in numbers]

print(new_list)

Reset

[11, 12, 13, 14, 15]
```

In the preceding example, x + 10 is the expression, x is the element, and numbers is the iterable sequence. There is no condition.

This next list comprehension extracts the first and last letter of each word as a tuple, but only if the word is more than five letters long.

```
words = ['Emotan', 'Amina', 'Ibeno', 'Sankwala']

new_list = [(word[0], word[-1]) for word in words if len(word) > 5]

print(new_list)

Reset

[('E', 'n'), ('S', 'a')]
```

Note that multiple operations can be performed in the expression component of the list comprehension to result in a list of tuples. This example also makes use of a condition to filter out words that are not more than five letters long.

## **Key takeaways**

zip(), enumerate(), and list comprehension make code more efficient by reducing the need to rely on loops to process data and simplifying working with iterables. Understanding these common tools will save you time and make your process much more dynamic when manipulating data.

<br> 

*** 

<br>

# Reference guide: Dictionaries

By now you’ve encountered dictionaries and are discovering their power and utility as a data structure in Python. You’ve also learned that dictionaries provide a way to store and retrieve data using key-value pairs. Data professionals use dictionaries for many tasks, so it’s important to be familiar with how they work. This reading is a reference guide about dictionaries. It’s designed to help you in your Python learning journey. 

## **Save this course item**

You may want to save a copy of this guide for future reference. Use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the link below and select “Use Template.” 

[Reference guide: Dictionaries](https://docs.google.com/document/d/1H1MZbLW6wA_my7dxF9WhmScSgxHSBbj1GknNLiLT0Ic/template/preview?pli=1)

OR

If you don’t have a Google account, download the item directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/orN4zwlFRIanqzgY1ldPAQ_b31e651899194cbfbdd71260217184f1_Reference-guide_-Dictionaries.docx?Expires=1710374400&Signature=Mw29pzWGQ8JIlx-XCghEWHWEl-rAXw8Jx3~ocg~XP3pRGaSKeIn~o8Sp6V-5jIVQUqwjHP1ugN6IrfzmhHrQcjqh3GDoHg57aqPffULeYauLdEqmAKAxONRf2BhspKc-sGaB8Rt1mr0yjPLshZAlwwr0MN7Bigzd8p3ByrLC06I_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## **Create a dictionary**

There are two main ways to create dictionaries in Python:

- Braces: {}
    
- The dict function: dict()
    

When instantiating a dictionary using braces, separate each element with a colon. For example, the following code creates a dictionary containing continents as keys and their smallest countries as values:

**Note:** The following code block is not interactive.

```
smallest_countries = {'Africa': 'Seychelles',

                     'Asia': 'Maldives',

                     'Europe': 'Vatican City',

                     'Oceania': 'Nauru',

                     'North America': 'St. Kitts and Nevis',

                     'South America': 'Suriname'

                     }
```

To create an empty dictionary, use empty braces or the dict() function:

**Note:** The following code block is not interactive.

```
empty_dict_1 = {}

empty_dict_2 = dict()
```

The dict() function uses a different syntax, where keys are entered as the function’s keyword arguments and values are assigned with an equals operator:

**Note:** The following code block is not interactive.

```
smallest_countries = dict(africa='Seychelles',

                         asia='Maldives',

                         europe='Vatican City',

                         oceania='Nauru',

                         north_america='St. Kitts and Nevis',

                         south_america ='Suriname'

)
```

Notice that, because the keywords cannot be entered as strings, they cannot contain whitespaces.

Some important notes about keys and values:

- **Dictionary keys:** Can be of any _immutable_ data type, such as strings, numbers, or tuples
    
- **Dictionary values:** Can be of any data type—mutable or immutable—including other dictionaries or objects
    
- Each key can only correspond to a single value; so, for example, this will throw an error:
    

```
invalid_dict = {'numbers': 1, 2, 3}

Reset

Error on line 1:
    invalid_dict = {'numbers': 1, 2, 3}
                                   ^
SyntaxError: invalid syntax
```

But if you enclose multiple values within another single data structure, you can create a valid dictionary. For example:

```
valid_dict = {'numbers': [1, 2, 3]}

print(valid_dict)

Reset

{'numbers': [1, 2, 3]}
```

## **Work with dictionaries**

### Access values

To access a specific value in a dictionary, you must refer to its key using brackets:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

print(my_dict['nums'])

Reset

[1, 2, 3]
```

To access all values in a dictionary, use the values() method:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

print(my_dict.values())

Reset

dict_values([[1, 2, 3], ['a', 'b', 'c']])
```

### Assign new keys

Dictionaries are mutable data structures in Python. You can add to and modify existing dictionaries. To add a new key to a dictionary, use brackets:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

# Add a new 'floats' key

my_dict['floats'] = [1.0, 2.0, 3.0]

print(my_dict)

Reset

{'nums': [1, 2, 3], 'abc': ['a', 'b', 'c'], 'floats': [1.0, 2.0, 3.0]}
```

### Check if a key exists in a dictionary

To check if a key exists in a dictionary, use the in keyword:

```
smallest_countries = {'Africa': 'Seychelles',

                     'Asia': 'Maldives',

                     'Europe': 'Vatican City',

                     'Oceania': 'Nauru',

                     'North America': 'St. Kitts and Nevis',

                     'South America': 'Suriname'

                     }

print('Africa' in smallest_countries)

print('Asia' not in smallest_countries)

Reset

True
False
```

### Delete a key-value pair

To delete a key-value pair from a dictionary, use the del keyword:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

del my_dict['abc']

print(my_dict)

Reset

{'nums': [1, 2, 3]}
```

## **Dictionary methods**

Dictionaries are a core Python class. As you’ve learned, classes package data with tools to work with it. Methods are functions that belong to a class. Dictionaries have a number of built-in methods that are very useful. Some of the most commonly used methods include:

### items()

Return a view of the (key, value) pairs of the dictionary:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

print(my_dict.items())

Reset

dict_items([('nums', [1, 2, 3]), ('abc', ['a', 'b', 'c'])])
```

### keys() 

Return a view of the dictionary’s keys:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

print(my_dict.keys())

Reset

dict_keys(['nums', 'abc'])
```

### values() 

Return a view of the dictionary’s values:

```
my_dict = {'nums': [1, 2, 3],

          'abc': ['a', 'b', 'c']

          }

print(my_dict.values())

Reset

dict_values([[1, 2, 3], ['a', 'b', 'c']])
```

Note that the objects returned by these methods are view objects. They provide a dynamic view of the dictionary’s entries, which means that, when the dictionary changes, the view reflects these changes. Dictionary views can be iterated over to yield their respective data. They also support membership tests. 

## **Additional resources**

- For more information about dictionaries, refer to the [Python dictionary documentation](https://docs.python.org/3/tutorial/datastructures.html#dictionaries).
    
- For more dictionary methods, refer to the [Python mapping types documentation](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict).
    
- For more information about view objects, refer to the [Python dictionary view objects documentation](https://docs.python.org/3/library/stdtypes.html#dict-views).

<br> 

*** 

<br>

# Reference guide: Sets

Data professionals depend on sets for separating data and identifying its unique elements. As you have been discovering, set objects are similar to lists and dictionaries, yet they do not have key-value pairs or positional index[i] capability. Additionally, sets contain unique values but have no item order or index behavior. Data professionals compare sets to understand the range of data they contain, where they intersect, and what items are present in either set but not both. Sets are also helpful when cleaning data for analysis. This reading is a reference guide for sets to help you as you continue learning Python.

## **Save this course item**

You may want to save a copy of this guide for future reference. Use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the link below and select “Use Template.” 

[Reference guide: Sets](https://docs.google.com/document/d/13ObxgpD7_EMt2rU09dmatLe8_0VVdGf_NZ64qfKFBoI/template/preview)

OR

If you don’t have a Google account, download the item directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/N69x4MbaQnufrhQ5SOqR_g_0602fef6c0eb4c719ac726904a2b12f1_Reference-guide_-Sets.docx?Expires=1710374400&Signature=CWCCokfaPqYaFS8jKGkaWJJ3-zDL2MBixwXcwGBY96ULChztOxXrWv2EhnmoYbKdDJQiYhpA-jtEgthqY~LnOVZlTznUwyx-Uk~e7H4n02x1XJ6ZsvkA-8qm8ehsXvpO0I-gLDAoKbVTtckBy9oBPGem6D9zRC~50-0Heldh5hs_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## **Sets review**

A set is a collection of unique data elements, without duplicates. In Python, it is an object class—in fact, two different classes—which you’ll learn about in this reading. However, sets are not unique to Python or even to computer programming; they are an important concept in general mathematics. Sets provide a simple means to identify unique data elements.

## **Create a set**

Create a set using braces:

my_set = {5, 10, 10, 20}

Note that an empty set cannot be created with braces, as this will be interpreted as an empty dictionary. 

There are two functions for creating sets in Python: set() and frozenset(). Use these on any iterable object. Or use these functions to create empty sets.

### [**set()**](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset)

- This is a mutable data type.
    
- Because it’s mutable, this class comes with [additional methods to add and remove data from the set](https://docs.python.org/3/library/stdtypes.html#frozenset.update).
    
- It can be applied to any iterable object and will remove duplicate elements from it.
    
- It is unordered and non-indexable. 
    
- Elements in a set must be hashable; generally, this means they must be immutable. (Refer to the additional resources for more information on hashing.)
    

In the examples that follow, four sets are instantiated using a variety of data types:

```
example_a = [1, 2, 2.0, '2']

set(example_a)

Reset

{1, 2, '2'}
```

Notice that, in the preceding example, 2 and 2.0 are evaluated as equivalent, even though one is an integer and the other is a float. 

```
example_b = ('apple', (1, 2, 2, 2, 3), 2)

set(example_b)

Reset

{2, 'apple', (1, 2, 2, 2, 3)}
```

In the preceding example, (1, 2, 2, 2, 3) is a tuple, which is hashable (≈ immutable) and thus treated as a distinct single element in the resulting set.

```
example_c = [1.5, {'a', 'b', 'c'}, 1.5]

set(example_c)

Reset

Error on line 2:
    set(example_c)
TypeError: unhashable type: 'set'
```

The preceding example throws an error because each element of a set must be hashable (≈ immutable), but {‘a’, ‘b’, ‘c’} is a set, which is a mutable (unhashable) object.

The following example demonstrates the add() method, which is one of the special methods available to sets but not to frozensets. 

```
example_d = {'mother', 'hamster', 'father'}

example_d.add('elderberries')

example_d

Reset

{'mother', 'father', 'elderberries', 'hamster'}
```

An element was added to the example_d set, thus modifying it. This is an example of the mutability of the set class.

### [frozenset()](https://docs.python.org/3/library/stdtypes.html#frozenset)

Frozensets are another type of set in Python. They are their own class, and they are very similar to sets, except they are immutable.

- This is an immutable data type.
    
- It can be applied to any iterable object and will remove duplicate elements from it.
    
- Because they’re immutable, frozensets can be used as dictionary keys and as elements in other sets.
    

In this example, a frozenset is used within a set.

```
example_e = [1.5, frozenset(['a', 'b', 'c']), 1.5]

set(example_e)

Reset

{1.5, frozenset({'c', 'b', 'a'})}
```

Unlike example_c previously, this set does not throw an error. This is because it contains a frozenset, which is an immutable type and can therefore be used in sets.

## Set methods

Sets are useful to determine which values are contained in a data structure and to eliminate duplicate values. There are numerous set methods—such as intersection, union, difference, and symmetric difference—that add functionality and power to working with sets.

### [union()](https://docs.python.org/3/library/stdtypes.html#frozenset.union) 

- Return a new set with elements from the set and all others.
    
- The operator for this function is the pipe ( | ).
    

```
set_1 = {'a', 'b', 'c'}

set_2 = {'b', 'c', 'd'}

print(set_1.union(set_2))

print(set_1 | set_2)

Reset

{'a', 'c', 'd', 'b'}
{'a', 'c', 'd', 'b'}
```

### [intersection()](https://docs.python.org/3/library/stdtypes.html#frozenset.intersection) 

- Return a new set with elements common to the set and all others.
    
- The operator for this function is the ampersand (&).
    

```
set_1 = {'a', 'b', 'c'}

set_2 = {'b', 'c', 'd'}

print(set_1.intersection(set_2))

print(set_1 & set_2)

Reset

{'b', 'c'}
{'b', 'c'}
```

### [difference()](https://docs.python.org/3/library/stdtypes.html#frozenset.difference) 

- Return a new set with elements in the set that are not in the others.
    
- The operator for this function is the subtraction operator ( - ).
    

```
set_1 = {'a', 'b', 'c'}

set_2 = {'b', 'c', 'd'}

print(set_1.difference(set_2))

print(set_1 - set_2)

Reset

{'a'}
{'a'}
```

### [symmetric_difference()](https://docs.python.org/3/library/stdtypes.html#frozenset.symmetric_difference) 

- Return a new set with elements in either the set or other, but not both.
    
- The operator for this function is the caret ( ^ ).
    

```
set_1 = {'a', 'b', 'c'}

set_2 = {'b', 'c', 'd'}

print(set_1.symmetric_difference(set_2))

print(set_1 ^ set_2)

Reset

{'d', 'a'}
{'d', 'a'}
```

## **Additional resources**

- Refer to the Python documentation for more information about [sets and frozensets](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset), including a complete list of available class methods.
    
- For methods unique to sets (and unavailable to frozensets), refer to this [Python set methods documentation](https://docs.python.org/3/library/stdtypes.html#frozenset.update).
    
- For more examples of sets, refer to the [Python tutorial on sets](https://docs.python.org/3/tutorial/datastructures.html#sets).
    
- For more information on hash tables, what makes something hashable, and hashing as a concept, refer to this [resource from Runestone Academy](https://runestone.academy/ns/books/published/pythonds/SortSearch/Hashing.html). For an interesting story about the birth of the original hashing algorithms, check out this [IEEE Spectrum article](https://spectrum.ieee.org/hans-peter-luhn-and-the-birth-of-the-hashing-algorithm).

<br> 

*** 

<br>


# Understand Python libraries, packages, and modules

Recently, you learned about Python libraries, packages, and modules. As you’ve discovered, importing these tools saves data professionals time and enhances their programming. Another benefit of commonly used  libraries is that they are constantly scrutinized and updated by talented and knowledgeable programmers. Thus, you can be confident that the underlying code is high quality. 

In this reading, you’ll learn more about the basic features of libraries, packages, and modules; how they are related; and a selection of basic modules you might use as a data professional.

## **Libraries, packages, and modules**

A **library** is a corpus of reusable code modules and their accompanying documentation. Libraries are bundled into **packages** that you install, which can then be imported into your coding environment as needed. You’ll typically encounter the terms “library” and “package” used interchangeably. Generally, this certificate program will refer to both as libraries, but it’s important to be acquainted with both terms.

**Modules** are similar to libraries, in that they are groups of related classes and functions, but they are generally subcomponents of libraries. In other words, a library can have many different modules, and you can choose to import the entire library or just the module you need. 

## **Import statements**

Libraries and modules beyond the Python standard library typically must be imported into your working environment on an as-needed basis. Additional libraries are installed first and then imported into your working environment as needed.

To import a library or module, use an import statement. Import statements require particular syntax using the **import** keyword. Here are some examples:

**Note:** The following code block is not interactive.

```
import numpy
```

This import statement imports the NumPy library into your working environment. After running this command, you’ll have access to all NumPy classes and functions. For instance, to use the array() function on [2, 4, 6], you’d write:

**Note:** The following code block is not interactive.

```
numpy.array([2, 4, 6])
```

Notice that to access the array() function, you must precede it with numpy, because this indicates that the function is coming from the NumPy library. 

### Aliasing

Another time-saver with Python libraries is aliasing. Aliasing helps you avoid typing a library's full name every time you want to access one of its functions. Instead, you’ll assign the library an **alias**. An alias is an abbreviated name, which is designated using the as keyword:

**Note:** The following code block is not interactive.

```
import numpy as np
```

In this case, the NumPy library is imported with the np alias. You can assign any abbreviation you like as an alias, but commonly used libraries have common aliases. Therefore, straying from those could cause confusion when sharing code with others. Here are some common libraries and their conventional aliases used by data professionals:

**Note:** The following code block is not interactive.

```
import numpy as np

import pandas as pd

import seaborn as sns

import matplotlib.pyplot as plt
```

NumPy is used for high-performance vector and matrix computations. Pandas is a library for manipulating and analyzing tabular data. Seaborn and matplotlib are both libraries used to create graphs, charts, and other data visualizations.

After running these imports, whenever you want to use a function from one of these libraries, precede the function with the alias. Returning to the example with NumPy’s array() function, after aliasing, you’d write:

**Note:** The following code block is not interactive.

```
np.array([2, 4, 6])
```

### Additional import syntax

#### **Importing modules**

Recall from the previous example:

**Note:** The following code block is not interactive.

```
import matplotlib.pyplot as plt
```

You may have noticed that this syntax differs slightly from the other examples. In this case, matplotlib is the library and pyplot is a module inside. The pyplot module is aliased as plt, and it’s accessed from the matplotlib library using the dot. 

#### **Importing functions**

Just as you can import libraries and modules, you can also import individual functions from libraries or from modules within libraries using a specific syntax. Here’s an example depicting a common import when using the scikit-learn library to build machine learning models:

**Note:** The following code block is not interactive.

```
from sklearn.metrics import precision_score, recall_score
```

Again, notice the different syntax. The import statement begins with the **from** keyword, followed by sklearn.metrics—the scikit-learn library + the metrics module. Next is the import keyword followed by the desired functions. In this case, there are two: precision_score and recall_score. 

The same syntax can be applied to the example using NumPy’s array() function. However, note that you typically would not encounter individual functions being imported from NumPy. It’s much easier and more common to just import the whole library.

**Note:** The following code block is not interactive.

```
from numpy import array
```

When a function is imported by name, like in this example, you can use it without any preceding syntax to indicate the library or module that it comes from:

**Note:** The following code block is not interactive.

```
array([2,4,6])
```

### Discouraged syntax

One last syntactical variation that you might encounter is:

**Note:** The following code block is not interactive.

```
from library.module import *
```

This imports everything from a particular library or module and allows you to use its functions without any preceding syntax. So, for instance, if you wrote from numpy import *,  you’d be able to use all of NumPy’s functions without preceding them with numpy or np. **This approach is not recommended** because it makes it difficult to track where functions come from. However, it’s helpful to be aware of this because you will likely encounter it in your work as a data professional. And, in specific instances, it might be useful.  

## **Commonly used built-in modules**

The Python standard library comes with a number of built-in modules relevant to data professional work such as math, datetime, and random. These can be imported without additional installation. In other words, you can import them directly, as long as you have Python installed. For example:

### [datetime](https://docs.python.org/3/library/datetime.html#module-datetime)

- Provides many helpful date and time conversions and calculations
    

Example:

```
import datetime  

date = datetime.date(1977, 5, 8)       # assign a date to a variable

print(date)                            # print date

print(date.year)                       # print the year that the date is in

delta = datetime.timedelta(days=30)    # assign a timedelta of 30 days to a 

                                       # variable

print(date - delta)                    # print date of 30 days prior 

Reset

1977-05-08
1977
1977-04-08
```

### [math](https://docs.python.org/3/library/math.html#module-math)

- Provides access to mathematical functions
    

Example:

```
import math  

print(math.exp(0))          # e**0

print(math.log(1))          # ln(1)

print(math.factorial(4))    # 4! 

print(math.sqrt(100))       # square root of 100

Reset

1.0
0.0
24
10.0
```

### [random](https://docs.python.org/3/library/random.html#module-random)

- Useful for generating pseudo-random numbers (refer to the documentation for explanation of pseudo-random number generation)
    

Example:

```
import random

print(random.random())          # 0.0 <= X < 1.0

print(random.choice([1, 2, 3])) # choose a random element from a sequence

print(random.randint(1, 10))    # a <= X <= b

Reset

0.511642967239646
3
6
```

## **Key takeaways**

Libraries, packages, and modules are gateways to Python's countless capabilities. Understanding how to leverage them for your own coding needs will unlock new tools and functions that make your work much more efficient. Check out the Python Package Index at the [PyPI](https://pypi.org/) repository to search for useful libraries. There are packages designed for applications as diverse as chemistry, audio editing, natural language processing, and video games. Whatever it is you’re trying to do, chances are someone has developed a suite of tools to help you!

<br> 

*** 

<br>



# Reference guide: Arrays

As you’ve learned, NumPy is a powerful library capable of performing advanced numerical computing. One of its main benefits is the ability to work with arrays, as an operation applied to a vector executes much faster than the same operation applied to a list. Performance increases become further apparent when working with large volumes of data. This reading is a reference guide for working with NumPy arrays. 

## **Save this course item**

You may want to save a copy of this guide for future reference. Use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the link below and select “Use Template.” 

[Reference guide: Arrays](https://docs.google.com/document/d/1NopsXs4caG8W2oDFt0JIsZvVa2MckyaifO0pCqPVzpA/template/preview?resourcekey=0-Q6qzwooboi4PO_vB2hnyhw)

OR

If you don’t have a Google account, download the item directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/9i71ShHNT5WTDlZ8XFdRvg_9ad850e01edc473cbed190c5c88cfdf1_Reference-guide_-Arrays.docx?Expires=1710374400&Signature=jeq00TfcDvDv9rTLiUSawHcaOKI6hlHbFTEyfzQHHEAmiBVKVWMfY-D9G1~RrHNbo2rO89Ya2rGOzLkVLx3M7ZVDGyA-WmHQYKcxiPvftjapaGRpNjzVAx6RUkLQHbsc5d5qgpVqSj9JQScsd85ZG4F~WFblJgAL-5LGszsDQ6s_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## **Create an array**

As you’ve discovered, to use NumPy, you must first import it. Standard practice is to alias it as np. 

### [**np.array()**](https://numpy.org/doc/stable/reference/generated/numpy.array.html)

This creates an ndarray (n-dimensional array). There is no limit to how many dimensions a NumPy array can have, but arrays with many dimensions can be more difficult to work with.

#### 1-D array:

```
import numpy as np

array_1d = np.array([1, 2, 3])

array_1d

Reset

[1 2 3]
```

Notice that a one-dimensional array is similar to a list.

#### 2-D array:

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

array_2d

Reset

[[1 2 3]
 [4 5 6]]
```

Notice that a two-dimensional array is similar to a table.

#### 3-D array:

```
array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

array_3d

Reset

[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
```

Notice that a three-dimensional array is similar to two tables.

### [np.zeros()](https://numpy.org/doc/stable/reference/generated/numpy.zeros.html)

- This creates an array of a designated shape that is pre-filled with zeros:
    

```
np.zeros((3, 2))

Reset

[[ 0.  0.]
 [ 0.  0.]
 [ 0.  0.]]
```

### [np.ones()](https://numpy.org/doc/stable/reference/generated/numpy.ones.html)

- This creates an array of a designated shape that is pre-filled with ones:
    

```
np.ones((2, 2))

Reset

[[ 1.  1.]
 [ 1.  1.]]
```

### [np.full()](https://numpy.org/doc/stable/reference/generated/numpy.full.html)

- And this creates an array of a designated shape that is pre-filled with a specified value:
    

```
np.full((5, 3), 8)

Reset

[[ 8.  8.  8.]
 [ 8.  8.  8.]
 [ 8.  8.  8.]
 [ 8.  8.  8.]
 [ 8.  8.  8.]]
```

These functions are useful for various situations:

- To initialize an array of a specific size and shape, then fill it with values derived from a calculation
    
- To allocate memory for later use
    
- To perform matrix operations
    

## **Array methods**

NumPy arrays have many methods that allow you to manipulate and operate on them. For a full list, refer to the [NumPy array documentation](https://numpy.org/doc/stable/reference/arrays.ndarray.html). Some of the most commonly used methods follow:

### [ndarray.flatten()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html)

- This returns a copy of the array collapsed into one dimension.
    

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

print(array_2d)

print()

array_2d.flatten()

Reset

[[1 2 3]
 [4 5 6]]

[1 2 3 4 5 6]
```

### [ndarray.reshape()](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html#numpy.reshape)

- This gives a new shape to an array without changing its data.
    

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

print(array_2d)

print()

array_2d.reshape(3, 2)

Reset

[[1 2 3]
 [4 5 6]]

[[1 2]
 [3 4]
 [5 6]]
```

Adding a value of -1 in the designated new shape makes the process more efficient, as it indicates for NumPy to automatically infer the value based on other given values.

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

print(array_2d)

print()

array_2d.reshape(3, -1)

Reset

[[1 2 3]
 [4 5 6]]

[[1 2]
 [3 4]
 [5 6]]
```

### [ndarray.tolist()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tolist.html)

- This converts an array to a list object. Multidimensional arrays are converted to nested lists. 
    

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

print(array_2d)

print()

array_2d.tolist()

Reset

[[1 2 3]
 [4 5 6]]

[[1, 2, 3], [4, 5, 6]]
```

### Mathematical functions

NumPy arrays also have many methods that are mathematical functions:

- [ndarray.max()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.max.html): returns the maximum value in the array or along a specified axis.
    
- [ndarray.mean()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.mean.html): returns the mean of all the values in the array or along a specified axis.
    
- [ndarray.min()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.min.html): returns the minimum value in the array or along a specified axis.
    
- [ndarray.std()](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.std.html): returns the standard deviation of all the values in the array or along a specified axis.
    

```
a = np.array([(1, 2, 3), (4, 5, 6)])

print(a)

print()

print(a.max())

print(a.mean())

print(a.min())

print(a.std())

Reset

[[1 2 3]
 [4 5 6]]

6
3.5
1
1.70782512766
```

## **Array attributes**

NumPy arrays have several attributes that enable you to access information about the array. Some of the most commonly used attributes include the following:

- [ndarray.shape](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html): returns a tuple of the array’s dimensions.
    
- [ndarray.dtype](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.dtype.html): returns the data type of the array’s contents.
    
- [ndarray.size](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.size.html): returns the total number of elements in the array.
    
- [ndarray.T](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.T.html): returns the array transposed (rows become columns, columns become rows).
    

```
array_2d = np.array([(1, 2, 3), (4, 5, 6)])

print(array_2d)

print()

print(array_2d.shape)

print(array_2d.dtype)

print(array_2d.size)

print(array_2d.T)

Reset

[[1 2 3]
 [4 5 6]]

(2, 3)
int64
6
[[1 4]
 [2 5]
 [3 6]]
```

## **Indexing and slicing**

Access individual elements of a NumPy array using indexing and slicing. Indexing in NumPy is similar to indexing in Python lists, except multiple indices can be used to access elements in multidimensional arrays.

```
a = np.array([(1, 2, 3), (4, 5, 6)])

print(a)

print()

print(a[1])

print(a[0, 1])

print(a[1, 2])

Reset

[[1 2 3]
 [4 5 6]]

[4 5 6]
2
6
```

Slicing may also be used to access subarrays of a NumPy array:

```
a = np.array([(1, 2, 3), (4, 5, 6)])

print(a)

print()

a[:, 1:]

Reset

[[1 2 3]
 [4 5 6]]

[[2 3]
 [5 6]]
```

## **Array operations**

NumPy arrays support many operations, including mathematical functions and arithmetic. These include array addition and multiplication, which performs element-wise arithmetic on arrays:

```
a = np.array([(1, 2, 3), (4, 5, 6)])

b = np.array([[1, 2, 3], [1, 2, 3]])

print('a:')

print(a)

print()

print('b:')

print(b)

print()

print('a + b:')

print(a + b)

print()

print('a * b:')

print(a * b)

Reset

a:
[[1 2 3]
 [4 5 6]]

b:
[[1 2 3]
 [1 2 3]]

a + b:
[[2 4 6]
 [5 7 9]]

a * b:
[[ 1  4  9]
 [ 4 10 18]]
```

In addition, there are nearly 100 other useful [mathematical functions](https://numpy.org/doc/stable/reference/routines.math.html#mathematical-functions) that can be applied to individual or multiple arrays.

## **Mutability**

NumPy arrays are mutable, but with certain limitations. For instance, an existing element of an array can be changed:

```
a = np.array([(1, 2), (3, 4)])

print(a)

print()

a[1][1] = 100

a

Reset

[[1 2]
 [3 4]]

[[1   2]
 [3 100]]
```

However, the array cannot be lengthened or shortened:

```
a = np.array([1, 2, 3])

print(a)

print()

a[3] = 100

a

Reset

Error on line 5:
    a[3] = 100
IndexError: index 3 is out of bounds for axis 0 with size 3
```

### How NumPy arrays store data in memory

NumPy arrays work by allocating a contiguous block of memory at the time of instantiation. Most other structures in Python don’t do this; their data is scattered across the system’s memory. This is what makes NumPy arrays so fast; all the data is stored together at a particular address in the system’s memory. 

Interestingly, this is also what prevents an array from being lengthened or shortened: The abutting memory is occupied by other information. There’s no room for more data at that memory address. However, existing elements of the array can be replaced with new elements. 

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/f67bd9fd-3083-4599-a974-a6a9ac819aec)

The only way to lengthen an array is to copy the existing array to a new memory address along with the new data.

<br> 

*** 

<br>



# The fundamentals of pandas

You’ve learned that Python has many open-source libraries and packages—including NumPy and pandas—that make it one of the most useful coding languages. In this reading, you will review the basics of pandas dataframes and learn more about how to work with them. Understanding the fundamentals of pandas is essential to becoming a capable and competent data professional.

## **Primary data structures**

Pandas has two primary data structures: Series and DataFrame. 

- Series**:** A Series is a one-dimensional labeled array that can hold any data type. It’s similar to a column in a spreadsheet or a one-dimensional NumPy array. Each element in a series has an associated label called an index. The index allows for more efficient and intuitive data manipulation by making it easier to reference specific elements of your data.
    
- DataFrame**:** A dataframe is a two-dimensional labeled data structure—essentially a table or spreadsheet—where each column and row is represented by a Series.
    

## **Create a DataFrame**

To use pandas in your notebook, first import it. Similar to NumPy, pandas has its own standard alias, pd, that’s used by data professionals around the world:

```
import pandas as pd
```

Once you’ve imported pandas into your working environment, create a dataframe. Here are some of the ways to create a DataFrame object in a Jupyter Notebook. 

**From a dictionary:**


```
d = {'col1': [1, 2], 'col2': [3, 4]}

df = pd.DataFrame(data=d)

df

Reset

   col1  col2
0     1     3
1     2     4
```

**From a numpy array:**

```
df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),

                  columns=['a', 'b', 'c'])

df2

Reset

   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
```

**From a comma-separated values (csv) file:**

(Note that this cell will not run, but is provided to illustrate syntax.)

```
df3 = pd.read_csv('/file_path/file_name.csv')
```

## **Attributes and methods**

The DataFrame class is powerful and convenient because it comes with a suite of built-in features that simplify common data analysis tasks. These features are known as attributes and methods. An attribute is a value associated with an object or class that is referenced by name using dotted expressions. A method is a function that is defined inside a class body and typically performs an action. A simpler way of thinking about the distinction between attributes and methods is to remember that attributes are _characteristics_ of the object, while methods are _actions_ or _operations_. 

**Common** DataFrame **attributes**

Data professionals use attributes and methods constantly. Some of the most-used DataFrame attributes include:

|**Attribute**|**Description**|
|---|---|
|[columns](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.columns.html#pandas.DataFrame.columns)|Returns the column labels of the dataframe|
|[dtypes](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dtypes.html#pandas.DataFrame.dtypes)|Returns the data types in the dataframe|
|[iloc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html#pandas.DataFrame.iloc)|Accesses a group of rows and columns using integer-based indexing|
|[loc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc)|Accesses a group of rows and columns by label(s) or a Boolean array|
|[shape](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shape.html#pandas.DataFrame.shape)|Returns a tuple representing the dimensionality of the dataframe|
|[values](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values)|Returns a NumPy representation of the dataframe|

**Common** DataFrame **methods**

Some of the most-used DataFrame methods include:

|**Method**|**Description**|
|---|---|
|[apply(_)_](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply)|Applies a function over an axis of the dataframe|
|[copy()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy)|Makes a copy of the dataframe’s indices and data|
|[describe()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe)|Returns descriptive statistics of the dataframe, including the minimum, maximum, mean, and percentile values of its numeric columns; the row count; and the data types|
|[drop()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop)|Drops specified labels from rows or columns|
|[groupby()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby)|Splits the dataframe, applies a function, and combines the results|
|[head(_n=5_)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html#pandas.DataFrame.head)|Returns the first _n_ rows of the dataframe (default=5)|
|[info()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info)|Returns a concise summary of the dataframe|
|[isna()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.isna.html#pandas.DataFrame.isna)|Returns a same-sized Boolean dataframe indicating whether each value is null (can also use isnull() as an alias)|
|[sort_values()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values)|Sorts by the values across a given axis|
|[value_counts()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts)|Returns a series containing counts of unique rows in the dataframe|
|[where()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where)|Replaces values in the dataframe where a given condition is false|

These are just a handful of some of the most commonly used attributes and methods—there are many, many more! Some of them can also be used on pandas Series objects. For a more detailed list, refer to the [pandas DataFrame documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html), which includes helpful examples of how to use each tool. 

## **Selection statements**

Once your data is read into a dataframe, you’ll want to do things with it by selecting, manipulating, and evaluating the data. In this section, you’ll learn how to select rows, columns, combinations of rows and columns, and basic subsets of data. 

### Row selection

Rows of a dataframe are selected by their index. The index can be referenced either by name or by numeric position. 

#### loc[]

loc[] lets you select rows by name. Here’s an example:

```
df = pd.DataFrame({

   'A': ['alpha', 'apple', 'arsenic', 'angel', 'android'],

   'B': [1, 2, 3, 4, 5],

   'C': ['coconut', 'curse', 'cassava', 'cuckoo', 'clarinet'],

   'D': [6, 7, 8, 9, 10]

   },

   index=['row_0', 'row_1', 'row_2', 'row_3', 'row_4'])

df

Reset

             A  B         C   D
row_0    alpha  1   coconut   6
row_1    apple  2     curse   7
row_2  arsenic  3   cassava   8
row_3    angel  4    cuckoo   9
row_4  android  5  clarinet  10
```

The row index of the dataframe contains the names of the rows. Use loc[] to select rows by name:

```
print(df.loc['row_1'])

Reset

A    apple
B        2
C    curse
D        7
Name: row_1, dtype: object
```

Inserting just the row index name in selector brackets returns a Series object. Inserting the row index name as a list returns a DataFrame object:

```
print(df.loc[['row_1']])

Reset

           A  B      C  D
row_1  apple  2  curse  7

```

To select multiple rows by name, use a list within selector brackets:

```
print(df.loc[['row_2', 'row_4']])

Reset

             A  B         C   D
row_2  arsenic  3   cassava   8
row_4  android  5  clarinet  10
```

You can even specify a range of rows by named index:

```
print(df.loc['row_0':'row_3'])

Reset

             A  B        C  D
row_0    alpha  1  coconut  6
row_1    apple  2    curse  7
row_2  arsenic  3  cassava  8
row_3    angel  4   cuckoo  9
```

**Note:** Because you’re using named indices, the returned range includes the specified end index.

#### iloc[]

iloc[] lets you select rows by numeric position, similar to how you would access elements of a list or an array. Here’s an example.

```
print(df)

print()

print(df.iloc[1])

Reset

             A  B         C   D
row_0    alpha  1   coconut   6
row_1    apple  2     curse   7
row_2  arsenic  3   cassava   8
row_3    angel  4    cuckoo   9
row_4  android  5  clarinet  10

A    apple
B        2
C    curse
D        7
Name: row_1, dtype: object
```

Inserting just the row index number in selector brackets returns a Series object. Inserting the row index number as a list returns a DataFrame object:

```
print(df.iloc[[1]])

Reset

           A  B      C  D
row_1  apple  2  curse  7
```

To select multiple rows by index number, use a list within selector brackets:

```
print(df.iloc[[0, 2, 4]])

Reset

             A  B         C   D
row_0    alpha  1   coconut   6
row_2  arsenic  3   cassava   8
row_4  android  5  clarinet  10
```

Specify a range of rows by index number:

```
print(df.iloc[0:3])

Reset

             A  B        C  D
row_0    alpha  1  coconut  6
row_1    apple  2    curse  7
row_2  arsenic  3  cassava  8
```

Note that this does not include the row at index three. 

### Column selection

#### Bracket notation

Column selection works the same way as row selection, but there are also some shortcuts to make the process easier. For example, to select an individual column, simply put it in selector brackets after the name of the dataframe:

```
print(df['C'])

Reset

row_0     coconut
row_1       curse
row_2     cassava
row_3      cuckoo
row_4    clarinet
Name: C, dtype: object
```

And to select multiple columns, use a list in selector brackets:

```
print(df[['A', 'C']])

Reset

             A         C
row_0    alpha   coconut
row_1    apple     curse
row_2  arsenic   cassava
row_3    angel    cuckoo
row_4  android  clarinet
```

#### Dot notation

It’s possible to select columns using dot notation instead of bracket notation. For example:

```
print(df.A)

Reset

row_0      alpha
row_1      apple
row_2    arsenic
row_3      angel
row_4    android
Name: A, dtype: object
```

Dot notation is often convenient and easier to type. However, it can make your code more difficult to read, especially in longer statements involving method chaining or condition-based selection. For this reason, bracket notation is often preferred.

#### loc[]

You can also use loc[] notation:

```
print(df)

print()

print(df.loc[:, ['B', 'D']])

Reset

             A  B         C   D
row_0    alpha  1   coconut   6
row_1    apple  2     curse   7
row_2  arsenic  3   cassava   8
row_3    angel  4    cuckoo   9
row_4  android  5  clarinet  10

       B   D
row_0  1   6
row_1  2   7
row_2  3   8
row_3  4   9
row_4  5  10
```

Note that when using loc[] to select columns, you must specify rows as well. In this example, all rows were selected using just a colon (:).

#### iloc[]

Similarly, you can use iloc[] notation. Again, when using iloc[], you must specify rows, even if you want to select all rows:

```
print(df.iloc[:, [1,3]])

Reset

       B   D
row_0  1   6
row_1  2   7
row_2  3   8
row_3  4   9
row_4  5  10
```

### Select rows and columns

Both loc[] and iloc[] can be used to select specific rows and columns together. 

#### loc[]

```
print(df.loc['row_0':'row_2', ['A','C']])

Reset

             A        C
row_0    alpha  coconut
row_1    apple    curse
row_2  arsenic  cassava
```

Again, notice that when using loc[] to select a range, the final element in the range is included in the results. 

#### iloc[]

```
print(df.iloc[[2, 4], 0:3])

Reset

             A  B         C
row_2  arsenic  3   cassava
row_4  android  5  clarinet
```

Note that, when using rows with named indices, you cannot mix numeric and named notation. For example, the following code will throw an error:

```
print(df.loc[0:3, ['D']])

Reset

Error on line 1:
    print(df.loc[0:3, ['D']])
```

To view rows [0:3] at column ‘D’ (if you don’t know the index number of column D), you’d have to use selector brackets after an iloc[] statement:

```
# This is most convenient for VIEWING: 

print(df.iloc[0:3][['D']])

# But this is best practice/more stable for assignment/manipulation:

print(df.loc[df.index[0:3], 'D'])

Reset

       D
row_0  6
row_1  7
row_2  8
row_0    6
row_1    7
row_2    8
Name: D, dtype: int64
```

However, in many (perhaps most) cases your rows will not have named indices, but rather numeric indices. In this case, you can mix numeric and named notation. For example, here’s the same dataset, but with numeric indices instead of named indices.

```
df = pd.DataFrame({

   'A': ['alpha', 'apple', 'arsenic', 'angel', 'android'],

   'B': [1, 2, 3, 4, 5],

   'C': ['coconut', 'curse', 'cassava', 'cuckoo', 'clarinet'],

   'D': [6, 7, 8, 9, 10]

   },

   )

df

Reset

         A  B         C   D
0    alpha  1   coconut   6
1    apple  2     curse   7
2  arsenic  3   cassava   8
3    angel  4    cuckoo   9
4  android  5  clarinet  10
```

Notice that the rows are enumerated now. Now, this code will execute without error:

```
print(df.loc[0:3, ['D']])

Reset

   D
0  6
1  7
2  8
3  9
```

## **Key takeaways**

Pandas dataframes are a convenient way to work with tabular data. Each row and each column can be represented by a pandas Series, which is similar to a one-dimensional array. Both dataframes and series have a large collection of methods and attributes to perform common tasks and retrieve information. Pandas also has its own special notation to select data. As you work more with pandas, you’ll become more comfortable with this notation and its many applications in data science.

## Resources for more information

- [pandas DataFrame class documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
    
- [pandas Series class documentation](https://pandas.pydata.org/docs/reference/series.html)
    
- [pandas selection documentation](https://pandas.pydata.org/docs/user_guide/10min.html#selection)


<br> 

*** 

<br>

# Boolean masking in pandas 

Now that you know how to select data in pandas by referring to rows and columns, the next step is to learn how to use Boolean masks. Data professionals use Boolean masks to select data in pandas based on conditions. In this reading, you will discover Boolean masking and how to use pandas’ logical operators to form multi-conditional selection statements. Understanding the fundamentals of pandas will help make your work as a data professional easier and more efficient.

## Boolean masks

You know that Boolean is used to describe any binary variable whose possible values are true or false. With pandas, **Boolean masking,** also called **Boolean indexing**, is used to overlay a Boolean grid onto a dataframe's index in order to select only the values in the dataframe that align with the True values of the grid. 

Return to the example from the video. Suppose you have a dataframe of planets, their radii, and their number of moons:

|**planet**|**radius_km**|**moons**|
|---|---|---|
|Mercury|2,440|0|
|Venus|6,052|0|
|Earth|6,371|1|
|Mars|3,390|2|
|Jupiter|69,911|80|
|Saturn|58,232|83|
|Uranus|25,362|27|
|Neptune|24,622|14|

Now suppose that you want to keep the rows of any planets that have fewer than 20 moons and filter out the rest. A Boolean mask is a pandas Series object indicating whether this condition is true or false for each value in the moons column:

||**Moons < 20?**|
|---|---|
|0|True|
|1|True|
|2|True|
|3|True|
|4|False|
|5|False|
|6|False|
|7|True|

The dtype contained in this series is bool. Boolean masking effectively overlays this Boolean series onto the dataframe’s index. The result is that any rows in the dataframe that are indicated as False in the Boolean mask get filtered out, and any rows that are indicated as True remain in the dataframe:

|**planet**|**radius_km**|**moons**|
|---|---|---|
|Mercury|2,440|0|
|Venus|6,052|0|
|Earth|6,371|1|
|Mars|3,390|2|
|Neptune|24,622|14|

### Coding Boolean masks in pandas 

Here is how to perform this operation in pandas.

Begin with a DataFrame object.

```
data = {'planet': ['Mercury', 'Venus', 'Earth', 'Mars',

                   'Jupiter', 'Saturn', 'Uranus', 'Neptune'],

       'radius_km': [2440, 6052, 6371, 3390, 69911, 58232,

                     25362, 24622],

       'moons': [0, 0, 1, 2, 80, 83, 27, 14]

        }

df = pd.DataFrame(data)

df

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
4     80  Jupiter      69911
5     83   Saturn      58232
6     27   Uranus      25362
7     14  Neptune      24622
```

Then, write a logical statement. Remember, the objective is to keep planets that have fewer than 20 moons and filter out the rest.

```
print(df['moons'] < 20)

Reset

0     True
1     True
2     True
3     True
4    False
5    False
6    False
7     True
Name: moons, dtype: bool
```

This results in a Series object of dtype: bool that consists of the row indices, where each index contains a True or False value depending on whether that row satisfies the given condition. This is the Boolean mask. To apply this mask to the dataframe, simply insert this statement into selector brackets and apply it to your dataframe:

```
print(df[df['moons'] < 20])

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
7     14  Neptune      24622
```

You can also assign the Boolean mask to a named variable and then apply that to your dataframe:

```
mask = df['moons'] < 20

df[mask]

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
7     14  Neptune      24622
```

Note that this doesn’t permanently modify your dataframe. It only gives a filtered view of it. 

```
df

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
4     80  Jupiter      69911
5     83   Saturn      58232
6     27   Uranus      25362
7     14  Neptune      24622
```

However, you can assign the result to a named variable:

```
mask = df['moons'] < 20

df2 = df[mask]

df2

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
7     14  Neptune      24622
```

And if you want to select just the planet column as a Series object, you can use regular selection tools like loc[]:

```
mask = df['moons'] < 20

df.loc[mask, 'planet']

Reset

0    Mercury
1      Venus
2      Earth
3       Mars
7    Neptune
Name: planet, dtype: object
```

### Complex logical statements

In statements that use multiple conditions, pandas uses logical operators to indicate which data to keep and which to filter out. These operators are:

|**Operator**|**Logic**|
|---|---|
|&|and|
|\||or|
|~|not|

**Important: Each component of a multi-conditional logical statement must be in parentheses.** Otherwise, the statement will throw an error or, worse, return something that isn’t what you intended.

For example, here is how to create a Boolean mask that selects all planets that have fewer than 10 moons or greater than 50 moons:

```
mask = (df['moons'] < 10) | (df['moons'] > 50)

mask

Reset

0     True
1     True
2     True
3     True
4     True
5     True
6    False
7    False
Name: moons, dtype: bool
```

Notice that each condition is self-contained in a set of parentheses, and the two conditions are separated by the logical operator, |(or). To apply the mask, call the dataframe and put the statement or the variable it’s assigned to in selector brackets:

```
mask = (df['moons'] < 10) | (df['moons'] > 50)

df[mask]

Reset

   moons   planet  radius_km
0      0  Mercury       2440
1      0    Venus       6052
2      1    Earth       6371
3      2     Mars       3390
4     80  Jupiter      69911
5     83   Saturn      58232
```

Here’s an example of how to select all planets that have more than 20 moons, but not planets with 80 moons and not planets with a radius less than 50,000 km:

```
mask = (df['moons'] > 20) & ~(df['moons'] == 80) & ~(df['radius_km'] < 50000)

df[mask]

Reset

   moons  planet  radius_km
5     83  Saturn      58232
```

Note that this returns the same result as the following:

```
mask = (df['moons'] > 20) & (df['moons'] != 80) & (df['radius_km'] >= 50000)

df[mask]

Reset

   moons  planet  radius_km
5     83  Saturn      58232
```

Working with pandas dataframes, using their attributes and methods, and selecting data using Boolean masks are some of the core daily activities of a data professional. You’ll soon be using these tools often as you progress on your journey with pandas.

## Key takeaways

A Boolean mask is a method of applying a filter to a dataframe. The mask overlays a Boolean grid over your dataframe in order to select only the values in the dataframe that align with the True values of the grid. To create Boolean comparisons, pandas has its own logical operators. These operators are:

- & (and) 
    
- | (or) 
    
- ~ (not)
    

Each criterion of a multi-conditional selection statement must be enclosed in its own set of parentheses. With practice, making complex selection statements in pandas is possible and efficient.

## Resources for more information

- [pandas Boolean indexing documentation](https://pandas.pydata.org/docs/user_guide/indexing.html#boolean-indexing)

<br> 

*** 

<br>


# More on grouping and aggregation

You’ve discovered that pandas is a Python library that facilitates reviewing and manipulating tabular data. In addition, groupby() and agg() are essential DataFrame methods that data professionals use to group, aggregate, summarize, and better understand data. In this reading, you’ll review how these functions work, as well as when and how to apply them. 

## groupby()

The [groupby()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html) function is a method that belongs to the DataFrame class. It works by splitting data into groups based on specified criteria, applying a function to each group independently, then combining the results into a data structure. When applied to a dataframe, the function returns a groupby object. This groupby object serves as the foundation for different data manipulation operations, including:

- Aggregation: Computing summary statistics for each group
    
- Transformation: Applying functions to each group and returning modified data
    
- Filtration: Selecting specific groups based on certain conditions
    
- Iteration: Iterating over groups or values
    

Here are some examples that use the groupby() function on a dataframe consisting of different articles of clothing:

```
clothes = pd.DataFrame({'type': ['pants', 'shirt', 'shirt', 'pants', 'shirt', 'pants'],

                       'color': ['red', 'blue', 'green', 'blue', 'green', 'red'],

                       'price_usd': [20, 35, 50, 40, 100, 75],

                       'mass_g': [125, 440, 680, 200, 395, 485]})

clothes

Reset

   color  mass_g  price_usd   type
0    red     125         20  pants
1   blue     440         35  shirt
2  green     680         50  shirt
3   blue     200         40  pants
4  green     395        100  shirt
5    red     485         75  pants
```

Grouping the dataframe by type results in a DataFrameGroupBy object:

```
grouped = clothes.groupby('type')

print(grouped)

print(type(grouped))

Reset

<pandas.core.groupby.DataFrameGroupBy object at 0x7f02c040d128>
<class 'pandas.core.groupby.DataFrameGroupBy'>
```

However, an aggregation function can be applied to the groupby object:

```
grouped = clothes.groupby('type')

grouped.mean()

Reset

       mass_g  price_usd
type                    
pants   270.0  45.000000
shirt   505.0  61.666667
```

In the preceding example, groupby() combined all the items into groups based on their type and returned a DataFrame object containing the mean of each group for each numeric column in the dataframe. Note: In future versions of pandas it will be necessary to specify a numeric_only parameter when applying certain aggregation functions—like mean—to a groupby object. numeric_only refers to the datatype of each column. In earlier versions of pandas (like the version on this platform) it isn't necessary to specify numeric_only=True, but in future versions this must be done. Otherwise, it will be necessary to indicate the specific columns to be captured.)

In addition, groups may be created based on multiple columns:

```
clothes.groupby(['type', 'color']).min()

Reset

             mass_g  price_usd
type  color                   
pants blue      200         40
      red       125         20
shirt blue      440         35
      green     395         50
```

In the preceding example, groupby() was called directly on the clothes dataframe. The data was grouped first by type, then by color. This resulted in four groups—the number of different existing combinations of values for type and color. Then, the min() function was applied to the result to filter each group by its minimum value.

To simply return the number of observations there are in each group, use the size() method. This will result in a Series object with the relevant information:

```
clothes.groupby(['type', 'color']).size()

Reset

type   color
pants  blue     1
       red      2
shirt  blue     1
       green    2
dtype: int64
```

### Built-in aggregation functions

The previous examples demonstrated the mean(), min(), and size() aggregation functions applied to groupby objects. There are many available built-in aggregation functions. Some of the more commonly used include:

- count(): The number of non-null values in each group
    
- sum(): The sum of values in each group
    
- mean(): The mean of values in each group
    
- median(): The median of values in each group
    
- min(): The minimum value in each group
    
- max(): The maximum value in each group
    
- std(): The standard deviation of values in each group
    
- var(): The variance of values in each group
    

## agg()

The [agg()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.agg.html) function is useful when you want to apply multiple functions to a dataframe at the same time. agg() is a method that belongs to the DataFrame class. It stands for “aggregate.” Its most important parameters are:  

- func: The function to be applied
    
- axis: The axis over which to apply the function (default= 0). 
    

Following are some examples of how agg() can be used. Note that they demonstrate how this function can be used by itself (without groupby()). Note also that, due to platform limitations, some of the following code blocks are not executable. In these cases, output is provided as an image. Here is the original clothes dataframe again as a reminder:

```
clothes

Reset

   color  mass_g  price_usd   type
0    red     125         20  pants
1   blue     440         35  shirt
2  green     680         50  shirt
3   blue     200         40  pants
4  green     395        100  shirt
5    red     485         75  pants
```

The following example applies the sum() and mean() functions to the price and mass_g columns of the clothes dataframe.

```
clothes[['price_usd', 'mass_g']].agg(['sum', 'mean'])
```

**Output:**

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/93fd905f-606f-46d6-bbf5-f9d703c14985)

Notice the following: 

- The two columns are subset from the dataframe before applying the agg() method. If you don’t subset the relevant columns first, agg() will attempt to apply sum() and mean() to _all_ of the columns, which wouldn’t work because some columns contain strings. (Technically, sum() would work, but it would return something useless because it would just combine all the strings into one long string.)
    
- The sum() and mean() functions are entered as strings in a list, without their parentheses. This will work for any built-in aggregation function.
    

In this next example, different functions are applied to different columns.

```
clothes.agg({'price_usd': 'sum',

            'mass_g': ['mean', 'median']

            })
```

**Output:**

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/b4991efb-8ca9-404b-a9da-412376265226)

Notice the following:

- Columns are not subset from the dataframe before applying the agg() function. This is unnecessary because the columns are specified within the agg() function itself.
    
- The argument to the agg() function is a dictionary whose keys are columns and whose values are the functions to be applied to those columns. If multiple functions are applied to a column, they are entered as a list. Again, each built-in function is entered as a string without parentheses.
    
- The resulting dataframe contains NaN values where a given function was not designated to be used.
    

The following example applies the sum() and mean() functions across axis 1. In other words, instead of applying the functions down each column, they’re applied over each row.

```
clothes[['price_usd', 'mass_g']].agg(['sum', 'mean'], axis=1)
```

**Output:**

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/4d6faec2-04ae-4605-86de-69c12d434947)

## groupby() **with** agg()

The groupby() and agg() functions are often used together. In such cases, first apply the groupby() function to a dataframe, then apply the agg() function to the result of the groupby. For reference, here is the clothes dataframe once again.

```
clothes

Reset

   color  mass_g  price_usd   type
0    red     125         20  pants
1   blue     440         35  shirt
2  green     680         50  shirt
3   blue     200         40  pants
4  green     395        100  shirt
5    red     485         75  pants
```

In the following example, the items in clothes are grouped by color, then each of those groups has the mean() and max() functions applied to them at the price_usd and mass_g columns.

```
clothes.groupby('color').agg({'price_usd': ['mean', 'max'],

                             'mass_g': ['mean', 'max']})

Reset

      price_usd      mass_g     
           mean  max   mean  max
color                           
blue       37.5   40  320.0  440
green      75.0  100  537.5  680
red        47.5   75  305.0  485
```

## **MultiIndex**

You might have noticed that, when functions are applied to a groupby object, the resulting dataframe has tiered indices. This is an example of **MultiIndex**. MultiIndex is a hierarchical system of dataframe indexing. It enables you to store and manipulate data with any number of dimensions in lower dimensional data structures such as series and dataframes. This facilitates complex data manipulation. 

This course will not require any deep knowledge of hierarchical indexing, but it’s helpful to be familiar with it. Consider the following example:

```
grouped = clothes.groupby(['color', 'type']).agg(['mean', 'min'])

grouped

Reset

            mass_g      price_usd    
              mean  min      mean min
color type                           
blue  pants  200.0  200      40.0  40
      shirt  440.0  440      35.0  35
green shirt  537.5  395      75.0  50
red   pants  305.0  125      47.5  20
```

Notice that color and type are positioned lower than the column names in the output. This indicates that color and type are no longer columns, but named row indices. Similarly, notice that price_usd and mass_g are positioned above mean and min in the output of column names, indicating a hierarchical column index. 

If you inspect the row index, you’ll get a MultiIndex object containing information about the row indices:

```
grouped.index

Reset

MultiIndex(levels=[['blue', 'green', 'red'], ['pants', 'shirt']],
           labels=[[0, 0, 1, 2], [0, 1, 1, 0]],
           names=['color', 'type'])
```

The column index shows a MultiIndex object containing information about the column indices:

```
grouped.columns

Reset

MultiIndex(levels=[['mass_g', 'price_usd'], ['mean', 'min']],
           labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
```

To perform selection on a dataframe with a MultiIndex, use loc[] selection and put indices in parentheses. Here are some examples on grouped, which is a dataframe with a two-level row index and a two-level column index. For reference, here is the grouped dataframe:

```
grouped

Reset

            mass_g      price_usd    
              mean  min      mean min
color type                           
blue  pants  200.0  200      40.0  40
      shirt  440.0  440      35.0  35
green shirt  537.5  395      75.0  50
red   pants  305.0  125      47.5  20
```

To select a first-level (top) column:

```
grouped.loc[:, 'price_usd']

Reset

             mean  min
color type            
blue  pants  40.0   40
      shirt  35.0   35
green shirt  75.0   50
red   pants  47.5   20
```

To select a second-level (bottom) column:

```
grouped.loc[:, ('price_usd', 'min')]

Reset

color  type 
blue   pants    40
       shirt    35
green  shirt    50
red    pants    20
Name: (price_usd, min), dtype: int64
```

To select first-level (left-most) row:

```
grouped.loc['blue', :]

Reset

      mass_g      price_usd    
        mean  min      mean min
type                           
pants  200.0  200      40.0  40
shirt  440.0  440      35.0  35
```

To select a bottom-level (right-most) row:

```
grouped.loc[('green', 'shirt'), :]

Reset

mass_g     mean    537.5
           min     395.0
price_usd  mean     75.0
           min      50.0
Name: (green, shirt), dtype: float64
```

And you can even select individual values:

```
grouped.loc[('blue', 'shirt'), ('mass_g', 'mean')]

Reset

440.0
```

If you want to remove the row MultiIndex from a groupby result, include as_index=False as a parameter to your groupby() statement:

```
clothes.groupby(['color', 'type'], as_index=False).mean()

Reset

   color   type  mass_g  price_usd
0   blue  pants   200.0       40.0
1   blue  shirt   440.0       35.0
2  green  shirt   537.5       75.0
3    red  pants   305.0       47.5
```

Notice how color and type are no longer row indices, but named columns. The row indices are the standard enumeration beginning from zero. 

Again, you will not be expected to do any complex manipulations of hierarchically indexed data in this course, but it’s helpful to have a basic understanding of how MultIndex works, especially because groupby() manipulations typically result in a MultiIndex dataframe by default. 

## Key takeaways

groupby() will be an essential function in your work as a data professional, as it enables efficient combining and analysis of data. Similarly, agg() will help you apply multiple functions dynamically across a specified axis of a dataframe. Either on their own or when used together, these tools give data professionals deep access to data and help bring about successful projects.


<br> 

*** 

<br>


# Glossary terms from module 4 

# Terms and definitions from Course 2, Module 4

**agg()**: A pandas groupby method that allows the user to apply multiple calculations to groups of data

**Aliasing**: A process that allows the user to assign an alternate name—or alias—to something

**append()**: A method that adds an element to the end of a list

**Boolean masking**: A filtering technique that overlays a Boolean grid onto a dataframe in order to select only the values in the dataframe that align with the True values of the grid

**concat()**: A pandas function that combines data either by adding it horizontally as new columns for existing rows or vertically as new rows for existing columns

**CSV file**: A plaintext file that uses commas to separate distinct values from one another; Stands for "comma-separated values”

**Data structure**: A collection of data values or objects that contain different data types

**DataFrame**: A two-dimensional, labeled data structure with rows and columns

**dict()**: A function used to create a dictionary

**Dictionary**: A data structure that consists of a collection of key-value pairs

**difference()**: A function that finds the elements present in one set but not the other

**dtype**: A NumPy attribute used to check the data type of the contents of an array

**Global variable**: A variable that can be accessed from anywhere in a program or script

**groupby()**: A pandas DataFrame method that groups rows of the dataframe together based on their values at one or more columns, which allows further analysis of the groups

**iloc[]**: A type of notation in pandas that indicates when the user wants to select by integer-location-based position

**Immutability**: The concept that a data structure or element’s values can never be altered or updated

**Import statement**: A statement that uses the import keyword to load an external library, package, module, or function into the computing environment

**Inner join**: A way of combining data such that only the keys that are in both dataframes get included in the merge

**insert()**: A function that takes an index as the first parameter and an element as the second parameter, then inserts the element into a list at the given index

**intersection()**: A function that finds the elements that two sets have in common

**items()**: A dictionary method to retrieve both the dictionary’s keys and values

**Keys**: The shared points of reference between different dataframes

**keys()**: A dictionary method to retrieve only the dictionary’s keys

**Left join**: A way of combining data such that all of the keys in the left dataframe are included, even if they aren’t in the right dataframe

**Library**: A reusable collection of code; also referred to as a “package”

**List**: A data structure that helps store and manipulate an ordered collection of items

**List comprehension**: Formulaic creation of a new list based on the values in an existing list

**loc[]**: Notation that is used to select pandas rows and columns by name

**matplotlib**: A library for creating static, animated, and interactive visualizations in Python

**merge()**: A pandas function that joins two dataframes together; it only combines data by extending along axis one horizontally

**Module**: A simple Python file containing a collection of functions and global variables 

**Mutability**: The ability to change the internal state of a data structure

**N-dimensional array**: The core data object of NumPy; also referred to as “ndarray”

**NaN**: How null values are represented in pandas; stands for “not a number”

**ndim**: A NumPy attribute used to check the number of dimensions of an array

**Nested loop**: A loop inside of another loop

**NumPy**: An essential library that contains multidimensional array and matrix data structures and functions to manipulate them

**Outer join**: A way of combining data such that all of the keys from both dataframes get included in the merge

**pandas**: A powerful library built on top of NumPy that’s used to manipulate and analyze tabular data

**pop()**: A method that extracts an element from a list by removing it at a given index

**remove()**: A method that removes an element from a list

**reshape()**: A NumPy method used to change the shape of an array

**Right join**: A way of combining data such that all the keys in the right dataframe are included—even if they aren’t in the left dataframe

**Seaborn**: A visualization library based on matplotlib that provides a simpler interface for working with common plots and graphs

**Sequence**: A positionally ordered collection of items

**Series**: A one-dimensional, labeled array where the data type must be the same for all the data in a given series

**Set**: A data structure in Python that contains only unordered, non-interchangeable elements

**set()**: A function that takes an iterable as an argument and returns a new set object

**shape**: A NumPy attribute used to check the shape of an array

**symmetric_difference()**: A function that finds elements from both sets that are mutually not present in the other

**Tabular data**: Data that is in the form of a table, with rows and columns 

**Tuple**: An immutable sequence that can contain elements of any data type

**tuple()**: A function that transforms input into tuples

**type()**: A function used to identify the type of data in a list

**union()**: A function that finds all the elements from both sets

**values()**: A dictionary method to retrieve only the dictionary’s values

**Vectorization**: A process that enables operations to be performed on multiple components of a data object at the same time

# Terms and definitions from previous modules

## A

**Algorithm**: A set of instructions for solving a problem or accomplishing a task

**Argument**: Information given to a function in its parentheses

**Assignment**: The process of storing a value in a variable

**Attribute**: A value associated with an object or class which is referenced by name using dot notation

## B

**Boolean**: A data type that has only two possible values, usually true or false

**Branching**: The ability of a program to alter its execution sequence

**break:** A keyword that lets a user escape a loop without triggering any ELSE statement that follows it in the loop

## C

**Cells**: The modular code input and output fields into which Jupyter Notebooks are partitioned

**Class**: An object’s data type that bundles data and functionality together

**Comparator**: An operator that compares two values and produces Boolean values (True/False)

**Computer programming**: The process of giving instructions to a computer to perform an action or set of actions

**Concatenate**: To link or join together

## D

**Data type**: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

**def**: A keyword that defines a function at the start of the function block

**Docstring**: A string at the beginning of a function’s body that summarizes the function’s behavior and explains its arguments and return values

**Dot notation**: How to access the methods and attributes that belong to an instance of a class

**Dynamic typing**: Variables that can point to objects of any data type

## E

**elif**: A reserved keyword that executes subsequent conditions when the previous conditions are not true 

**else**: A reserved keyword that executes when preceding conditions evaluate as False

**Escape character**: A character that changes the typical behavior of the characters that follow it

**Explicit conversion**: The process of converting a data type of an object to a required data type

**Expression**: A combination of numbers, symbols, or other variables that produce a result when evaluated

## F

**Float**: A data type that represents numbers that contain decimals

**For loop**: A piece of code that iterates over a sequence of values

**format()**: A string method that formats and inserts specific substrings into designated places within a larger string

**Function**: A body of reusable code for performing specific processes or tasks

## I

**if**: A reserved keyword that sets up a condition in Python

**Immutable data type**: A data type in which the values can never be altered or updated

**Implicit conversion**: The process Python uses to automatically convert one data type to another without user involvement

**index()**: A string method that outputs the index number of a character in a string

**Indexing**: A way to refer to the individual items within an iterable by their relative position

**Integer**: A data type used to represent whole numbers without fractions

**Iterable**: An object that’s looped, or iterated, over

**Iteration**: The repeated execution of a set of statements, where one iteration is the single execution of a block of code

## J

**Jupyter Notebook**: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

## K

**Keyword**: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

## L

**Logical operator**: An operator that connects multiple statements together and performs complex comparisons

**Loop**: A block of code used to carry out iterations 

## M

**Markdown**: A markup language that lets the user write formatted text in a coding environment or plain-text editor 

**Method**: A function that belongs to a class and typically performs an action or operation

**Modularity**: The ability to write code in separate components that work together and that can be reused for other programs

**Modulo**: An operator that returns the remainder when one number is divided by another

## N

**Naming conventions**: Consistent guidelines that describe the content, creation date, and version of a file in its name

**Naming restrictions**: Rules built into the syntax of the language itself that must be followed

## O

**Object**: An instance of a class; a fundamental building block of Python

**Object-oriented programming**: A programming system that is based around objects which can contain both data and code that manipulates that data

## P

**Programming languages**: The words and symbols used to write instructions for computers to follow

## R

**range()**: A Python function that returns a sequence of numbers starting from zero, increments by 1 by default, and stops before the given number

**Refactoring**: The process of restructuring code while maintaining its original functionality

**return**: A reserved keyword in Python that makes a function produce new results which are saved for later use

**Reusability**: The capability to define code once and use it many times without having to rewrite it

## S

**Self-documenting code**: Code written in a way that is readable and makes its purpose clear

**String**: A sequence of characters and punctuation that contains textual information

**String slice**: A portion of a string that can contain more than one character; also referred to as a substring 

**Syntax**: The structure of code words, symbols, placement, and punctuation

## V

**Variable**: A named container which stores values in a reserved location in the computer’s memory

## W

**While** **loop**: A loop that instructs the computer to continuously execute the code based on the value of a condition

# Module 5 Course 2 end-of-course project

<br> 

*** 

<br>


# Explore your Course 2 workplace scenarios

# **Overview**

This certificate offers you a choice of several different workplace scenarios to use when completing each end-of-course project:

- Automatidata, featuring a fictional data consulting firm
    
- TikTok, created in partnership with the short-form video hosting company
    
- Waze, created in partnership with the realtime driving directions app 
    

Each scenario offers you an opportunity to apply your skills and create work samples to share when applying for jobs; so, you will be practicing similar skills regardless of the workplace scenario. It is recommended that you work with the same scenario for each end-of-course project to have a cohesive experience. However, you are welcome to investigate any of the workplace scenarios you are interested in as you progress through the program. 

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/19760693-156c-4c25-bbaa-3d43d9d53a7e)

_**Reminder:**_ _We recommend that you choose one workplace scenario to follow for all end-of-course projects to ensure end-to-end project development._

The minimum requirement to earn your Advanced Data Analytics Certificate is to complete the end-of-course project, using one workplace scenario, for each course. You may complete the project for as many of the workplace scenarios as you wish. Completing the project for more than one workplace scenario in a single course offers you additional practice and work examples you can add to your portfolio and share with prospective employers during your job search.

This reading offers an overview of all available workplace scenarios. Before moving on, identify the scenario you would like to compete for the Course 2 end-of-course project.

## **Course 2 workplace scenarios**

## Automatidata

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/1b75ccd5-0afb-43ef-972f-df37f8addcf6)

**Project goal:** 

In this fictional scenario, the New York City Taxi and Limousine Commission (TLC) has approached the data consulting firm Automatidata to develop an app that enables TLC riders to estimate the taxi fares in advance of their ride.

**Background:** 

Since 1971, TLC has been regulating and overseeing the licensing of New York City's taxi cabs, for-hire vehicles, commuter vans, and paratransit vehicles.

**Scenario:**

You have received notice that the recently submitted New York City TLC project proposal has been approved. The Automatidata team now has access to the New York City TLC data to analyze, identify key variables, and prepare for exploratory data analysis.

**Course 2 tasks:**

- Load data, explore, and extract the New York City TLC data with Python
    
- Use custom functions to organize the information within the New York City TLC dataset
    
- Build a dataframe for the New York City TLC project
    
- Create an executive summary for Automatidata
    

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

## **TikTok**

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/2d69823e-82e2-4dda-a9a8-232732c07128)

**Project goal:** 

The TikTok data team is developing a machine learning model for classifying claims made in videos submitted to the platform.

**Background:** 

TikTok is the leading destination for short-form mobile video. The platform is built to help imaginations thrive. TikTok's mission is to create a place for inclusive, joyful, and authentic content–where people can safely discover, create, and connect.

**Scenario:** 

As a data analyst on TikTok's data team, you'll help by preparing the data needed for the claims classification project. You’ll build a dataframe, organize the claims data for the process of exploratory data analysis, and update the team on your progress and insights.

**Course 2 tasks:**

- Build a dataframe for the TikTok dataset
    
- Read in data from TikTok csv file
    
- Display rows within dataframe
    
- Examine data type of each column
    
- Gather descriptive statistics
    
- Visualize the TikTok data in Python
    
- Report to TikTok’s data team through an executive summary
    

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

## **Waze**

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/1fe2d865-2d30-4d7b-a61d-38c10876731f)

**Project goal:** 

Waze leadership has asked your data team to develop a machine learning model to predict user churn. Churn quantifies the number of users who have uninstalled the Waze app or stopped using the app. This project focuses on monthly user churn. An accurate model will help prevent churn, improve user retention, and grow Waze’s business.

**Background:** 

Waze’s free navigation app makes it easier for drivers around the world to get to where they want to go. Waze’s community of map editors, beta testers, translators, partners, and users helps make each drive better and safer. 

**Scenario:** 

Your team is in the early stages of their user churn project. Your project proposal has been approved and your team has been given access to Waze’s user data. To get clear insights, the data must first be inspected, organized, and prepared for analysis. 

**Course 2 tasks:**

- Import data
    
- Create a dataframe 
    
- Inspect data 
    
- Identify outliers
    
- Create a data visualization
    
- Share an executive summary with the Waze data team 
    

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

## **Key Takeaways**

In Course 2, Get Started with Python, you were introduced to some basics of the Python programming language. You explored syntax, loops, strings, lists, dictionaries, object-oriented programming, and explored how data professionals use code on the job. 

### **Course 2 skills:**

- Code with Python
    
- Create data visualization
    
- Use comments to enhance code readability
    
- Work within a Jupyter Notebook
    
- Share insights and ideas with stakeholders
    

### **Course 2 end-of-course project deliverables:** 

- Build a dataframe
    
- Create an executive summary
    

The end-of-course portfolio projects are designed for you to apply your data analytical skills within a workplace scenario. No matter which scenario you work with, you will practice your ability to discuss data analytic topics with coworkers, internal team members, and external clients.

As a reminder, you are required to complete one project for each course. To gain additional practice, or to add more samples to your portfolio, you may complete as many of the scenarios as you wish.

<br> 

*** 

<br>

# Course 2 end-of-course portfolio project overview: Automatidata

# **Learn about the Course 2 Automatidata workplace scenario!**

The end-of-course project in Course 2 focuses on your ability to understand the data needed for a project. As a reminder, in Course 1 you developed a project proposal that outlined milestones, which progress with each of the end-of-course projects. A visual representation is provided in the graphic shown here:

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/7f1520d4-c370-4dfd-925c-dedd0d6c0a68)

Learn more about the project, your role, and expectations in this reading.  

## **Background on the Automatidata scenario**

Automatidata works with its clients to transform their unused and stored data into useful solutions, such as performance dashboards, customer-facing tools, strategic business insights, and more. They specialize in identifying a client’s business needs and utilizing their data to meet those business needs. 

Automatidata is consulting for the New York City Taxi and Limousine Commission (TLC). New York City TLC is an agency responsible for licensing and regulating New York City's taxi cabs and for-hire vehicles. The agency has partnered with Automatidata to develop a regression model that helps estimate taxi fares before the ride, based on data that TLC has gathered. 

The TLC data comes from over 200,000 taxi and limousine licensees, making approximately one million combined trips per day. 

**Note:** _This project's dataset was created for pedagogical purposes and may not be indicative of New York City taxi cab riders' behavior._

## **Team members at Automatidata and the New York City TLC**

### **Automatidata Team Members**

- Udo Bankole, Director of Data Analysis
    
- Deshawn Washington, Data Analysis Manager
    
- Luana Rodriquez, Senior Data Analyst
    
- Uli King, Senior Project Manager
    

Your teammates at Automatidata have technical experience with data analysis and data science. However, you should always be sure to keep summaries and messages to these team members concise and to the point. 

### **New York City TLC Team Members**

- Juliana Soto, Finance and Administration Department Head
    
- Titus Nelson, Operations Manager
    

The TLC team members are program managers who oversee operations at the organization. Their roles are not highly technical, so be sure to adjust your language and explanation accordingly.

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

### **Project background**

Automatidata is in the earliest stages of the TLC project. The following tasks are needed before the team can begin the data analysis process:

- Build a dataframe for the TLC dataset
    
- Examine data type of each column
    
- Gather descriptive statistics
    

### Your assignment

You will build a dataframe for the TLC data. After the dataframe is complete, you will organize the data for the process of exploratory data analysis, and update the team on your progress and insights.

## **Specific project deliverables**

With this end-of-course project, you will gain valuable practice and apply your new skills as you complete the following:

- Complete the questions in the Course 2 PACE strategy document
    
- Answer the questions in the Jupyter notebook project file
    
- Complete coding prep work on project’s Jupyter notebook
    
- Summarize the column Dtypes
    
- Communicate important findings to DeShawn and Luana in the form of an executive summary  
    

Good luck with this project! Automatidata looks forward to seeing how you communicate your creative work and approach problem-solving! 

# **Key takeaways** 

The Google Advanced Data Analytics Certificate end-of-course project is designed for you to practice and apply course skills in a fictional workplace scenario. By completing each course’s end-of-course project, you will have work examples that will enhance your portfolio and showcase your skills for future employers.

<br> 

*** 

<br>


# Activity Exemplar: Create your Course 2 Automatidata project

Here are completed exemplars along with an explanation of how the exemplars fulfill the expectations for the activity. 

## Completed Exemplars

To review the exemplar for the Course 2 executive summary, click the following link and select Use Template.

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/aXzDQtT5TO-ye0ohsxIqZw_37a97efc28d843adba9196594d4a83f1_image.png?expiry=1710460800000&hmac=Z0Ep56IjJQpPZQPv2OqaopT375aQ9hqu4v88cQCtnww)

- [Course 2 executive summary](https://docs.google.com/presentation/d/1crEmW5ucXEth7GK1lfVUd_BeNhAXXgmEtvc-hB52Ih4/template/preview) 
    

OR

If you do not have a Google account, you can download the exemplar directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/d_bJBofWT8O9oM4YBen24A_d50aea2befad4918ac4d9da8df0308f1_Activity-Exemplar_-Course-2-Automatidata-executive-summary.pptx?Expires=1710460800&Signature=CjZ6amTlr4OlzZv5uTwqBjfP5k0PSbpIeY10tnUwTOZAgYx~a5r5twv0uWpaNJ6tVkYIBB88ilHn5Blug4W-W6QIonjG6Bi1MXSj1ZWxS4wBySLBRyseUfCLdoFOqO9SaULIh~3loae8J5hT36AuKL876228tzhcO2HQyEtOsgc_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/OYFyxVPIQb6xRjtzFxjl-g_c97e12939d964c84bf5fb7369a06a9f1_image.png?expiry=1710460800000&hmac=Ifd8lc1tyw9o0ht2bFQmriNHbxVi_TmK_URwS0yObGQ)

_**Note**__: The following lab is also the next course item._ 

To access the exemplar for the end-of-course project lab, click the following link and select _Open Lab_. 

- [Course 2 Automatidata project lab](https://www.coursera.org/learn/get-started-with-python/ungradedLab/fvJDh/exemplar-course-2-automatidata-project-lab)
    

## Assessment of Exemplar

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/ZmMVBxgoSVe1JOiV6eErGA_8e34df852b134f6ba0420ef9852966f1_image.png?expiry=1710460800000&hmac=nsgLnR-iiSVfXHQpAUooP-SxoCDL2WJDewae0iHaIuA)

### Course 2 Automatidata project lab 

Compare the exemplar to the Python notebook you completed. Your responses might differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate.

_**Note:**_ _The exemplar represents one possible way to complete the Python notebook. Yours might differ in certain ways, such as your specific code input or responses to questions. What's important is that you have an overall understanding of the purpose and functionality of a Python notebook for data analysis._

Your Python notebook should: 

- Include the correct code for inspecting and organizing your data
    
- Clearly communicate your responses to questions about code input and results
    

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/9BXrrASUSxqjP4eALevC8A_f44857c731a947808c2f746e2f483bf1_image.png?expiry=1710460800000&hmac=7reKx5BLGHDBk3ayzcaZUEZGCUFEMi-aLZKvW5gKMzY)

### Course 2 executive summary 

Compare the exemplar to your completed executive summary. Your responses might differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate. 

_**Note:**_ _The exemplar represents one possible way to complete the executive summary. Yours might differ in certain ways, such as your specific language, answers to questions or the layout you selected from the template offerings. What’s important is that you have an overall understanding of the purpose and organization of executive summaries for data projects._ 

Your executive summary should: 

- Include key information that you want to share with teammates and/or stakeholders
    
- Use clear and concise language to effectively communicate your results

<br> 

*** 

<br>

# Course 2 end-of-course portfolio project overview: TikTok

# **Learn about the Course 2 TikTok workplace scenario!**

The end-of-course project in Course 2 focuses on your ability to understand the data needed for a project. As a reminder, in Course 1 you developed a project proposal that outlined milestones, which progress with each of the end-of-course projects. A visual representation is provided in the graphic shown here:

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/b912753c-16c6-4840-85f6-6ba844fde44f)

Learn more about the project, your role, and expectations in this reading.  

## **Background on the TikTok scenario**

At TikTok, our mission is to inspire creativity and bring joy. Our employees lead with curiosity and move at the speed of culture. Combined with our company's flat structure, you'll be given dynamic opportunities to make a real impact on a rapidly expanding company and grow your career.

TikTok users have the ability to submit reports that identify videos and comments that contain user claims. These reports identify content that needs to be reviewed by moderators. The process generates a large number of user reports that are challenging to consider in a timely manner. 

TikTok is working on the development of a predictive model that can determine whether a video contains a claim or offers an opinion. With a successful prediction model, TikTok can reduce the backlog of user reports and prioritize them more efficiently.

### **Project background**

TikTok’s data team is in the earliest stages of the claims classification project. The following tasks are needed before the team can begin the data analysis process:

- Build a dataframe for the TikTok dataset
    
- Examine data type of each column
    
- Gather descriptive statistics
    

### Your assignment

You will build a dataframe for the claims classification data. After the dataframe is complete, you will organize the claims data for the process of exploratory data analysis, and update the team on your progress and insights.

## **Team members at TikTok**

### **Data team roles**

- Willow Jaffey- Data Science Lead
    
- Rosie Mae Bradshaw- Data Science Manager
    
- Orion Rainier- Data Scientist
    

The members of the data team at TikTok are well versed in data analysis and data science. Messages to these more technical coworkers should be concise and specific.

### **Cross-functional team members**

- Mary Joanna Rodgers- Project Management Officer
    
- Margery Adebowale- Finance Lead, Americas
    
- Maika Abadi- Operations Lead
    

Your TikTok team includes several managers, who oversee operations. It is important to adjust your general correspondence appropriately to their roles, given that their responsibilities are less technical in nature. 

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

## **Specific project deliverables**

With this end-of-course project, you will gain valuable practice and apply your new skills as you complete the following:

- Course 2 PACE Strategy Document to plan your project while considering your audience members, teammates, key milestones, and overall project goal. 
    
- Answer the questions in the Jupyter notebook project file
    
- Complete coding prep work on project’s Jupyter notebook
    
- Summarize the column Dtypes
    
- Communicate important findings in the form of an executive summary  
    

TikTok's data team needs you to problem-solve and communicate your findings. Good luck on your tasks!

## **Key takeaways** 

The Google Advanced Data Analytics Certificate end-of-course project is designed for you to practice and apply course skills in a fictional workplace scenario. By completing each course’s end-of-course project, you will have work examples that will enhance your portfolio and showcase your skills for future employers.

<br> 

*** 

<br>


# Activity Exemplar: Create your Course 2 TikTok project

Here are completed exemplars along with an explanation of how the exemplars fulfill the expectations for the activity. 

## Completed Exemplars

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/uFr4W54xROuFewIcdwt8TA_33f72f0a2c0043b79f5cfbbcbfaa9df1_image.png?expiry=1710460800000&hmac=soLHn7g3fxVL3rau6dY7ZqMa553fyVdVC8CxUd3FB74)

To review the exemplar for the Course 2 executive summary, click the following link and select _Use Template_. 

- [Course 2 executive summary](https://docs.google.com/presentation/d/1Vwo9pPwFLOFEu69x0qLEv_StHMSofU5E59AQkW0c_f8/template/preview?resourcekey=0-cEC-fVSgozZqLR-IS0hPZg) 
    

OR

If you do not have a Google account, you can download the exemplar directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/9vE9qDsUSlmG0n01Gj-Zcw_93f22862ec844768ac393326c3c52df1_Activity-Exemplar_-TikTok-Course-2-executive-summary.pptx?Expires=1710460800&Signature=JTOAwLPSL47s2IE9p8VsnCmHqbJHvG8YD4Szm72QBs~tWxdr1hftEe-4Fu9eq9bnK2jiRpGg8iogEDcH6K1CYJto6JUaK8rj~278Y7fIJM0yv3EARl6aO14dj6EfSL1g-HXQCfvCNREhUYMD5IW1-xz266izmF-horOGfbZmg4Q_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/wpLPpnEgTF29AWO208uwuw_76ebf4662d1241339aa0f450afc6bff1_image.png?expiry=1710460800000&hmac=RCMQRm0uMoU6mwy0c0Y3YII7diiWxOB-MJUHKKk7CQw)

_**Note**__: The following lab is also the next course item._ 

To access the exemplar for the end-of-course project lab, click the following link and select _Open Lab_. 

- [Course 2 TikTok project lab](https://www.coursera.org/learn/get-started-with-python/ungradedLab/MEiVL/exemplar-course-2-tiktok-project-lab)
    

## Assessment of Exemplars

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/Oh_3m5DtScyz3ZFntG2-8Q_b218db627d23466bb996429086bf43f1_image.png?expiry=1710460800000&hmac=mUB0BolQInDi2_7JaqcUMZ-nZCd6Syvl5K2yrNwSQGM)

### Course 2 TikTok project lab

Compare the exemplar to the Python notebook you completed. Your responses may differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate.

_**Note:**_ _The exemplar represents one possible way to complete the Python notebook. Yours may differ in certain ways, such as your specific code input or responses to questions. What's important is that you have an overall understanding of the purpose and functionality of a Python notebook for data analysis._

Your Python notebook should: 

- Include the correct code for inspecting and organizing your data
    
- Clearly communicate your responses to questions about code input and results
    

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/YY_2lHhkRTertS4rnCmtQg_39cb8c2d98124dbc8f4c8a1fe03c2ff1_image.png?expiry=1710460800000&hmac=RhbV0ZQf09w7NqET_DKQDDzUuWq4vvzPv67fQKOxpEo)

### Course 2 executive summary 

Compare the exemplar to your completed executive summary. Your responses may differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate.

_**Note:**_ _The exemplar represents one possible way to complete the executive summary. Yours might differ in certain ways, such as your specific language, answers to questions or the layout you selected from the template offerings. What’s important is that you have an overall understanding of the purpose and organization of executive summaries for data projects._ 

Your executive summary should: 

- Include key information that you want to share with teammates and/or stakeholders
    
- Use clear and concise language to effectively communicate your results


<br> 

*** 

<br>


# Course 2 end-of-course portfolio project overview: Waze

# **Learn about the Course 2 Waze workplace scenario!**

The end-of-course project in Course 2 focuses on your ability to understand the data needed for a project. As a reminder, in Course 1 you developed a project proposal that outlined milestones, which progress with each of the end-of-course projects. A visual representation is provided in the graphic shown here:

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/266632d1-ad10-4b18-a35e-a7567ef8fbca)

Learn more about the project, your role, and expectations in this reading.

## **Background on the Waze scenario**

Waze’s free navigation app makes it easier for drivers around the world to get to where they want to go. Waze’s community of map editors, beta testers, translators, partners, and users helps make each drive better and safer. Waze partners with cities, transportation authorities, broadcasters, businesses, and first responders to help as many people as possible travel more efficiently and safely. 

You’ll collaborate with your Waze teammates to analyze and interpret data, generate valuable insights, and help leadership make informed business decisions. Your team is about to start a new project to help prevent user churn on the Waze app. Churn quantifies the number of users who have uninstalled the Waze app or stopped using the app. This project focuses on monthly user churn. 

This project is part of a larger effort at Waze to increase growth. Typically, high retention rates indicate satisfied users who repeatedly use the Waze app over time. Developing a churn prediction model will help prevent churn, improve user retention, and grow Waze’s business. An accurate model can also help identify specific factors that contribute to churn and answer questions such as: 

- Who are the users most likely to churn?
    
- Why do users churn? 
    
- When do users churn? 
    

For example, if Waze can identify a segment of users who are at high risk of churning, Waze can proactively engage these users with special offers to try and retain them. Otherwise, Waze may lose these users without knowing why. 

Your insights will help Waze leadership optimize the company’s retention strategy, enhance user experience, and make data-driven decisions about product development.

### **Project background**

Waze’s data team is in the earliest stages of the churn project. The following tasks are needed before the team can begin the data analysis process:

- Build a dataframe for the churn dataset
    
- Examine data type of each column
    
- Gather descriptive statistics
    
- Your assignment
    

### **Your assignment**

You will build a dataframe for the churn data. After the dataframe is complete, you will organize the data for the process of exploratory data analysis, and update the team on your progress and insights.

## **Team members at Waze**

### **Data team roles**

- Harriet Hadzic - Director of Data Analysis 
    
- May Santner - Data Analysis Manager 
    
- Chidi Ga - Senior Data Analyst 
    
- Sylvester Esperanza - Senior Project Manager 
    

Data team members have technical experience with data analysis and data science. However, you should always be sure to keep summaries and messages to these team members concise and to the point. 

### **Cross-functional team members**

- Emrick Larson - Finance and Administration Department Head 
    
- Ursula Sayo - Operations Manager 
    

Your Waze team includes several managers overseeing operations. It is important to adapt your communication to their roles since their responsibilities are less technical.

_**Note:**_ _The story, all names, characters, and incidents portrayed in this project are fictitious. No identification with actual persons (living or deceased) is intended or should be inferred. And, the data shared in this project has been created for pedagogical purposes._ 

## **Specific project deliverables**

With this end-of-course project, you will gain valuable practice and apply your new skills as you complete the following:

- Complete the questions in the Course 2 PACE strategy document
    
- Answer the questions in the Jupyter notebook project file
    
- Complete coding prep work on project’s Jupyter notebook
    
- Summarize the column Dtypes
    
- Communicate important findings in the form of an executive summary  
    

Good luck with this project! Your Waze team members are looking forward to seeing how you communicate your creative work and approach problem-solving!

## **Key takeaways** 

The Google Advanced Data Analytics Certificate end-of-course project is designed for you to practice and apply course skills in a fictional workplace scenario. By completing each course’s end-of-course project, you will have work examples that will enhance your portfolio and showcase your skills for future employers.

<br> 

*** 

<br>


# Activity Exemplars: Create your Course 2 Waze project

Here are completed exemplars along with an explanation of how the exemplars fulfill the expectations for the activity. 

## Completed Exemplars

To review the exemplar for the Course 2 executive summary, click the following link and select _Use Template_.

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/FO7yWqJ7Tom4zFsLO2w2Ow_dfe977b1f3f14f9ba6d67d3532cce5f1_image.png?expiry=1710460800000&hmac=0N4NlFxP3kLpxR-GTKlQ7RHJfIfF_7opLzAg7W61IS0)

- [Course 2 Executive summary](https://docs.google.com/presentation/d/1OwW2mHUZ6vjWwOGIUv_Wr7msvTOHDJaepjKh3gjewjY/template/preview) 
    

OR

If you do not have a Google account, you can download the exemplar directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/9cl0TY-fRPa_Fay_e7kkUg_1f52a495178840188a503cccd7cb29f1_Activity-Exemplar_-Waze-Course-2-executive-summary.pptx?Expires=1710460800&Signature=OYsp7lHtkVqMczdOdflVZqgKcQe2in6KuQxZJFL7qPdfKawgQCZQs-xFHA4jaFPQ-de-JhqVKhydiRXXbDHC3nOiTxhSPhDnQ7lbMD1mdJ8mep~2io1J0D0ZfObLLLidX0X9UqNQlQGUIm6BOim4vNK0Ekj4taGtsRMhUqEFLIg_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/x5f0AQOQQc2jWofofHjCPw_782d15f8169941c888fd9e6d988ab0f1_image.png?expiry=1710460800000&hmac=0UbJfHoS3pIVCg54fqcpWY2RiQro9QAfBRqiGzMEre4)

_**Note**__: The following lab is also the next course item._ 

To access the exemplar for the end-of-course project lab, click the following link and select _Open Lab_. 

- [Course 2 Waze project lab](https://www.coursera.org/learn/get-started-with-python/ungradedLab/IMizQ/exemplar-course-2-waze-project-lab)
    

## Assessment of Exemplar

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/xZcxUmU6QPK8ZYVYzDSPyw_2a684412c8ab4f5ca7dd38c7dcb97ff1_image.png?expiry=1710460800000&hmac=LTRUSbZWmLsLKmVTcp3sVF6mmtyr3mUFiaGF_nplSqE)

### Course 2 Waze project lab

Compare the exemplar to the Python notebook you completed. Your responses might differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate.

_**Note:**_ _The exemplar represents one possible way to complete the Python notebook. Yours might differ in certain ways, such as your specific language, answers to questions or the layout you selected from the template offerings. What's important is that you have an overall understanding of the purpose and functionality of a Python notebook for data analysis._

Your Python notebook should: 

- Include the correct code for inspecting and organizing your data
    
- Clearly communicate your responses to questions about code input and results 
    

![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/9K0hiIWYTSew4TYjthto-g_df3bca68077244eea866e3d38d6f89f1_image.png?expiry=1710460800000&hmac=285-wvbiFCY2v4Bv9KUExdKPJCmLquPcZXfVhiliWuU)

### Course 2 executive summary 

Compare the exemplar to your completed executive summary. Your responses might differ from the exemplar, but that is to be expected. What did you do well? Where can you improve? Use your answers to these questions to guide you as you progress through the end-of-course projects in the certificate.

_**Note:**_ _The exemplar represents one possible way to complete the executive summary. Yours might differ in certain ways, such as your specific language and or layout selected from the template offerings. What’s important is that you have an overall understanding of the purpose and organization of executive summaries for data projects._

Your executive summary should: 

- Include key information that you want to share with teammates and/or stakeholders
    
- Use clear and concise language to effectively communicate your results

<br> 

*** 

<br>


# Course 2 glossary

To use the template for this course item, click the link below and select “Use Template.”

Link to glossary: [Course 2 glossary](https://docs.google.com/document/d/18EAseAzwHSU_ngjtVZLn93IMXNNMoYzo45YPyzOoc_g/template/preview?resourcekey=0-UxG4GBCaaxPCFkrmg--0iA#heading=h.gpf6r5lm49h)

OR

If you don’t have a Google account, you can download the template directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/R_S5AS9OSTKhkacNFOgd1g_c70068fdfb43487380fdf0ba05b1c7f1_Course-2-glossary.docx?Expires=1710460800&Signature=GxE8wR2RL06PQyY0CqVz9wqZCHqKSx1IwMy9zVUlODmat~TacpKIuGT1XSDQ49BpswSHGBIMxAm945W3tznLIml4IXGwpy9s~34mppZ0dYSZgAeazxAeTJP2eISNA~bEiM86NL6-12WmJuKxOfngCRXmJ1L9WY~CwztiHoHlpco_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)