# Module 1 Hello, Python!

# Helpful resources and tips

As a learner, you can choose to complete one or multiple courses in this program. However, to obtain the certificate, you must complete all the courses in the program. This reading describes what is required to obtain a certificate and best practices for you to have a good learning experience on Coursera.  

## Obtain the Google Advanced Data Analytics Certificate

To receive your official Google Advanced Data Analytics Certificate, you must:

- Pass all graded assignments in all 7 courses of the certificate program. Each graded assignment is part of a cumulative graded score for the course, and the passing grade for each course is 80%. 
    

AND **one** of the following:

- Pay the [course certificate fee](https://www.coursera.support/s/article/209818963-Payments-on-Coursera?language=en_US),
    
- Be approved for [Coursera Financial Aid](https://www.coursera.support/s/article/209819033-Apply-for-Financial-Aid-or-a-Scholarship?language=en_US), **or**
    
- Complete the certificate through an educational institution, employer, or agency that's sponsoring your participation. 
    

## Healthy habits for course completion

Here is a list of best practices that will help you complete the courses in the program in a timely manner:

- **Plan your time:** Setting regular study times and following them each week can help you make learning a part of your routine. Use a calendar or timetable to create a schedule, and list what you plan to do each day in order to set achievable goals. Find a space that allows you to focus when you watch the videos, review the readings, and complete the activities.
    
- **Work at your own pace:** Everyone learns differently, so this program has been designed to let you work at your own pace. Although your personalized deadlines start when you enroll, feel free to progress through the program at the speed that works best for you. There is no penalty for late assignments; to earn your certificate, all you have to do is complete all of the work. You can extend your deadlines at any time by going to **Overview** in the navigation panel and selecting **Switch Sessions**. If you have already missed previous deadlines, select **Reset my deadlines** instead.
    
- **Be curious:** If you find an idea that gets you excited, act on it! Ask questions, search for more details online, explore the links that interest you, and take notes on your discoveries. The steps you take to support your learning along the way will advance your knowledge, create more opportunities in this high-growth field, and help you qualify for jobs. 
    
- **Take notes:** Notes will help you remember important information in the future, especially as you’re preparing to enter a new job field. In addition, taking notes is an effective way to make connections between topics and gain a better understanding of those topics.
    
- **Review exemplars:** Exemplars are completed assignments that fully meet an activity's criteria. Many activities in this program have exemplars for you to compare to your own work. Although there are often many ways to complete an assignment, exemplars offer you guidance and inspiration about how to complete the activity. 
    
- **Chat (responsibly) with other learners:** If you have a question, chances are, you’re not alone. Use the [discussion forums](https://www.coursera.org/learn/get-started-with-python/discussions) to ask for help from other learners taking this program. You can also visit Coursera’s [Global Online Community](https://coursera.community/). Other important things to know while learning with others can be found in the [Coursera Honor Code](https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code) and [Code of Conduct](https://learner.coursera.help/hc/en-us/articles/208280036-Coursera-Code-of-Conduct). 
    
- **Update your profile:** Consider [updating your profile](https://www.coursera.org/account/profile) on Coursera to include your photo, career goals, and more. When other learners find you in the discussion forums, they can click on your name to access your profile and get to know you better.
    

## Documents, spreadsheets, presentations, and labs for course activities

To complete certain activities in the program, you will need to use digital documents, spreadsheets, presentations, and/or labs. Data analytics professionals use these software applications to collaborate within their teams and organizations. If you need more information about using a particular tool, refer to these resources:

- [Microsoft Word: Help and learning](https://support.microsoft.com/en-us/word): Microsoft Support page for Word
    
- [Google Docs](https://support.google.com/docs/topic/9046002?hl=en&ref_topic=1382883): Help Center page for Google Docs
    
- [Microsoft Excel: Help and learning](https://support.microsoft.com/en-us/excel): Microsoft Support page for Excel
    
- [Google Sheets](https://support.google.com/docs/topic/9054603?hl=en&ref_topic=1382883): Help Center page for Google Sheets
    
- [Microsoft PowerPoint: Help and learning](https://support.microsoft.com/en-us/powerpoint): Microsoft Support page for PowerPoint
    
- [How to use Google Slides](https://support.google.com/docs/answer/2763168?hl=en&co=GENIE.Platform%3DDesktop): Help Center page for Google Slides  
    
- [Common problems with labs](https://support.google.com/qwiklabs/answer/9133560?hl=en&ref_topic=9134804): Troubleshooting help for Qwiklabs activities
    

## Module, course, and certificate glossaries

This program covers a lot of terms and concepts, some of which you may already know and some of which may be unfamiliar to you. To review terms and help you prepare for graded quizzes, refer to the following glossaries:

- **Module glossaries**: At the end of each module’s content, you can review a glossary of terms from that module. Each module’s glossary builds upon the terms from the previous modules in that course. The module glossaries are not downloadable; however, all of the terms and definitions are included in the course and certificate glossaries, which are downloadable.
    
- **Course glossaries**: At the end of each course, you can access and download a glossary that covers all of the terms in that course. 
    
- **Certificate glossary**: The certificate glossary includes all of the terms in the entire certificate program and is a helpful resource that you can reference throughout the program or at any time in the future. 
    

You can access and download the certificate glossaries and **save them on your computer.** You can **always find the** course and certificate glossaries through each course’s Resources section. To access the **Advanced Data Analytics Certificate glossary**, click the link below and select _Use Template_.

- Link to the glossary: [Advanced Data Analytics Certificate glossary](https://docs.google.com/document/d/193-AtS7MlB2w4buwiCyPjBoOhIbbByKgHWPpYnSR9VI/template/preview)
    

OR

- If you don’t have a Google account, you can download the glossary directly from the following attachment.
    

[file](https://d3c33hcgiwev3.cloudfront.net/hh5fTi8iRiSd_QFMpbgudg_6afdc847dcb2418a8d6626674ce6a5f1_Advanced-Data-Analytics-Certificate-glossary.docx?Expires=1710028800&Signature=KjJ9bNd3W30F2ZzSrFx05tkczOeAxkHSTm-XiWpvCHzg0btL9D-iYigNnPoJdaoWVGALuOLNwq-Uwotm6uJwAJeyNBShscII7AkRZQixZ3O~vMFmdJCRwg7XwJTy~1SEil3MMFwVhXZcH~85SGZKQr~aBk9GRQmj-JB6QKwqOlM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Data Analytics Certificate glossary

If you completed the original [Google Data Analytics Certificate](https://www.coursera.org/professional-certificates/google-data-analytics?utm_source=google&utm_medium=institutions&utm_campaign=gwgsite-gDigital-paidha-sem-bk-gen-exa-glp-br-null&_ga=2.170664992.1625030801.1661901112-1742325342.1661901112), you may recognize some overlap with several of the glossary terms in this program. Refer to the Data Analytics Certificate glossary, linked in the [Resources](https://www.coursera.org/learn/get-started-with-python/resources/E23KB) tab, to review these foundational terms and concepts. The definitions of some terms in the Data Analytics Certificate glossary differ from the definitions of the same terms in this program since the Advanced Data Analytics Certificate builds upon the concepts taught in the previous program.

## Course feedback

Providing feedback on videos, readings, and other materials is easy. With the resource open in your browser, you can find the thumbs-up and thumbs-down symbols. 

- Click **thumbs-up** for materials you find helpful. 
    
- Click **thumbs-down** for materials that you do not find helpful.
    

If you want to flag a specific issue with an item, click the flag icon, select a category, and enter an explanation in the text box. This feedback goes back to the course development team and isn’t visible to other learners. All feedback received helps to create even better certificate programs in the future.

For technical help, visit the [Learner Help Center](https://learner.coursera.help/hc/en-us).

<br> 

*** 

<br>

# Course 2 overview

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/19947469-cb87-4f70-9f17-a830f9104b89)

Hello, and welcome to **Get Started with Python**, the second course in the Google Advanced Data Analytics Certificate. You’re on an exciting journey!

Throughout this course, you will develop an understanding of Python syntax, logic, data types, objects, and object-oriented programming. For many professionals, Python is the key to unlocking advanced analytics, machine learning, and the world of data science. By the end of this course, you will better understand how data scientists use programming on the job and how Python will be an important tool throughout your career as a data analytics professional.

## Course descriptions

The Google Advanced Data Analytics Certificate has seven courses. **Get Started with Python** is the second course.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/f6bae109-7c8a-416c-841f-8ed3db9450e7)

1. [**Foundations of Data Science**](https://www.coursera.org/learn/foundations-of-data-science/home/week/1) — Learn how data professionals operate in the workplace and how different roles in the field of data science contribute to an organization’s vision of the future. Then, explore data science roles, communication skills, and data ethics.
    
2. [**Get Started with Python**](https://www.coursera.org/learn/get-started-with-python/home/week/1) — _(current course)_ Discover how the programming language Python can power your data analysis. Learn core Python concepts, such as data types, functions, conditional statements, loops, and data structures.
    
3. [**Go Beyond the Numbers: Translate Data into Insights**](https://www.coursera.org/learn/go-beyond-the-numbers-translate-data-into-insight/home/week/1) — Learn the fundamentals of data cleaning and visualizations and how to reveal the important stories that live within data.
    
4. [**The Power of Statistics**](https://www.coursera.org/learn/the-power-of-statistics/home/week/1) — Explore descriptive and inferential statistics, basic probability and probability distributions, sampling, confidence intervals, and hypothesis testing.
    
5. [**Regression Analysis: Simplify Complex Data Relationships**](https://www.coursera.org/learn/regression-analysis-simplify-complex-data-relationships/home/week/1) — Learn to model variable relationships, focusing on linear and logistic regression.
    
6. [**The Nuts and Bolts of Machine Learning**](https://www.coursera.org/learn/the-nuts-and-bolts-of-machine-learning/home/week/1) — Learn unsupervised machine learning techniques and how to apply them to organizational data. 
    
7. [**Google Advanced Data Analytics Capstone**](https://www.coursera.org/learn/google-advanced-data-analytics-capstone/home/week/1) — Complete a hands-on project designed to demonstrate the skills and competencies you acquire in the program. 
    

## Course 2 content

Each course of this certificate program is broken into modules. You can complete courses at your own pace, but the module breakdowns are designed to help you finish the entire Google Advanced Data Analytics Certificate in about six months.

What’s to come? Here’s a quick overview of the skills you’ll learn in each module of this course.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/0ddd8965-89b4-422b-a573-8b4e84138f27)

**Module 1: Hello, Python!** 

You’ll begin by exploring the basics of Python programming and why Python is such a powerful tool for data analysis. You’ll learn about Jupyter Notebooks, an interactive environment for coding and data work. You’ll investigate how to use variables and data types to store and organize your data; and, you'll begin practicing some important coding skills.

**Module 2: Functions and conditional statements**

Next, you’ll discover how to call functions to perform useful actions on your data. You’ll also learn how to write conditional statements to tell the computer how to make decisions based on your instructions. And you’ll practice writing clean code that can be easily understood and reused by other data professionals.

**Module 3: Loops and strings**

After that, you’ll learn how to use iterative statements, or loops, to automate repetitive tasks. You’ll also learn how to manipulate strings using slicing, indexing, and formatting. 

**Module 4: Data structures in Python**

Then, you’ll explore fundamental data structures such as lists, tuples, dictionaries, sets, and arrays. Lastly, you’ll learn about two of the most widely used and important Python tools for advanced data analysis: NumPy and pandas. 

**Module 5: Course 2 end-of-course project**

At the end of this course, you will put everything you have learned about Python so far into practice with an end-of-course project. You will select a business problem from a list of options and use the given data to solve the problem. This project is an opportunity to demonstrate your skills and build a professional portfolio you can use to showcase your work to potential employers. 

## What to expect

Each course offers many types of learning opportunities:

- **Videos** led by Google instructors teach new concepts, introduce the use of relevant tools, offer career support, and provide inspirational personal stories. 
    
- **Readings** build on the topics discussed in the videos, introduce related concepts, share useful resources, and describe case studies.
    
- **Discussion prompts** explore course topics for better understanding and allow you to chat and exchange ideas with other learners in the [**discussion forums**](https://www.coursera.org/learn/get-started-with-python/discussions).
    
- **Self-review activities** and **labs** give you hands-on practice in applying the skills you are learning and allow you to assess your own work by comparing it to a completed example.
    
- **In-video quizzes** help you check your comprehension as you progress through each video.
    
- **Practice quizzes** allow you to check your understanding of key concepts and provide valuable feedback.
    
- **Graded quizzes** demonstrate your understanding of the main concepts of a course. You must score 80% or higher on each graded quiz to obtain a certificate, and you can take a graded quiz multiple times to achieve a passing score.
    

## Tips for success

- It is strongly recommended that you go through the items in each lesson in the order they appear because new information and concepts build on previous knowledge.
    
- Participate in all learning opportunities to gain as much knowledge and experience as possible.
    
- If something is confusing, don’t hesitate to replay a video, review a reading, or repeat a self-review activity.
    
- Use the additional resources that are referenced in this course. They are designed to support your learning. You can find all of these resources in the [**Resources**](https://www.coursera.org/learn/get-started-with-python/resources/GnHn1) tab.
    
- When you encounter useful links in this course, bookmark them so you can refer to the information later for study or review.
    
- Understand and follow the [Coursera Code of Conduct](https://www.coursera.support/s/article/208280036-Coursera-Code-of-Conduct?) to ensure that the learning community remains a welcoming, friendly, and supportive place for all members.


<br> 

*** 

<br>

# Python versus other programming languages

Python is one of the most popular programming languages for data professionals, which makes it a great addition to your data analytics toolbox! As we’ve previously investigated, Python’s use of syntax to communicate commands and perform tasks mirrors spoken language. This makes Python a much easier programming language to learn. Python’s structure is similar to many other programming languages, but there are some key differences to consider as well.

In this reading, you’ll learn how Python compares to other programming languages data professionals use, including R, Java, and C++. 

## Five considerations of programming languages

Python isn’t the only programming language used for data analysis, but it is one of the most widely used and most powerful. Many data professionals even use more than one programming language. Every language has benefits and drawbacks. For the purposes of this course, examine the following considerations: speed, approachability, variables, data science focus, and programming paradigm.

### **Speed**

There are many factors that contribute to the speed of a program’s execution, including compile time, runtime, hardware, installed dependencies, and the efficiency of the code itself. In general, low-level programming languages are faster, but they’re more difficult to learn and work with. 

### **Approachability**

Approachability refers to how easy it is for new learners to start using a language. Learning new programming languages can be challenging depending on their syntax and overall structure. The **syntax** is the structure of code words, symbols, placement, and punctuation. Semantics builds meaning into those structures by using variables and objects. Additionally, those variables help add flexibility to the programs and objects where data is housed. 

### **Variables**

Information in code is stored in variables. A **variable** is a named container which stores values in a reserved location in the computer’s memory. The way a programming language uses variables will have an effect on a system's core operations or kernel speed. Some languages use static variables to maintain a value throughout the entire run of a program. Others approach variables as dynamic, allowing values to be determined when a program is run. Some languages even allow declarative variables, which enable a program to determine where a variable should be placed. 

### **Data science focus**

Programming languages have individual characteristics and can better serve different tasks in data analysis; this means programmers often use them for specific data science tasks. 

### **Programming paradigm**

Programming languages can be object-oriented, functional, or imperative. Object-oriented programming languages are modeled around data objects. Functional programming languages are modeled around functions. Imperative languages are modeled around code statements that can alter the state of the program itself. 

## Programming language comparisons

Python, R, Java and C++ are four of the most commonly used programming languages for data analysis. The following chart compares them using five considerations: speed, accessibility, variable, data science focus, and programming paradigm. 

|**Features by Software**|**Python**|**R**|**Java**|**C++**|
|---|---|---|---|---|
|**Speed**|Slower|Depends on configuration and add-ons|Faster|Very fast|
|**Approachability**|Easy to learn|Complex|Easy to learn|Complex|
|**Variable**|Dynamic|Dynamic|Static|Declarative|
|**Data science focus**|Machine learning and automated analysis|Exploratory data analysis and building extensive statistical libraries|Used across projects with open-source assets|Not as widely used but very powerful implementations|
|**Programming Paradigm**|Object-oriented|Functional language|Object-oriented|Multi-paradigm (imperative & object-oriented)|

## Key takeaways

There are a number of different programming languages that can be used for data analysis. Each language has its own benefits and drawbacks. Learning to work with different languages will give you the opportunity to broaden your data skills and access new tools for your analysis. However, in this certificate program, Python will be your sole focus. As mentioned previously, Python is an easy to learn, object-oriented programming language that engages dynamic variables; though it sometimes requires a longer time to execute, it is a great tool for machine learning and automated analysis.# How to use Jupyter Notebooks

Jupyter Notebook is an open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text. This is a great tool to develop and present code in a standardized text block format that is interactive and shareable. You can create code, mathematical formulas, data visualizations, and even freestyle text—all in Jupyter notebooks!

You will be using Jupyter notebooks to write, execute, and present your own code throughout this program. This reading will guide you through using your own notebook. Note, however, that for this certificate program you do not need to download any software. You can complete all activities with the tools provided on the Coursera platform.

# Jupyter Notebook

You can access Jupyter Notebook directly from your browser or download the desktop application onto your device to work with over 100 programming languages, including some you might already know like R and Python. There is [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/), which is the full suite of tools for working with computational notebooks. There is also [Jupyter Notebook](https://jupyter-notebook.readthedocs.io/en/stable/), which is a more streamlined and simplified tool that nonetheless offers powerful ways to perform interactive computing. Again, for this certificate program, we recommend working within the Jupyter Notebook interface provided by Coursera. Activities that use Jupyter notebooks will be labeled as labs, and you will find relevant instructions for each activity on its landing page.

# Why Jupyter Notebook?

Notebooks are particularly useful for working with data. Here are some ways that Jupyter notebooks excel:

1. **Modular/interactive computing:** You can write and execute individual chunks of code in small, manageable chunks, which are called cells. You can run a cell without necessarily having to run the whole notebook. This is especially helpful for data exploration and experimentation. Cells are also helpful with debugging, because they provide a user-friendly way to make a mistake, notice that you made the mistake, and iterate back to correct your mistake, without having to re-execute a whole script.
    
2. **Integration of code and documentation:** Notebooks allow you to combine code, textual explanations, and visualizations like charts, graphs, and tables—all in a single document. 
    
3. **Support for multiple languages:** The Advanced Data Analytics program will use Python, but Jupyter notebooks support many other languages, making them powerful and versatile.
    
4. **Data exploration and analysis:** The notebook simplifies working with data by offering tools to load, clean, analyze, and examine it in an elegant interface.
    
5. **Cloud-based services:** Many cloud computing platforms host Jupyter notebooks, which makes it easy to run and share notebooks without setting up a local environment. This is very useful for collaboration.
    
6. **Libraries and extensions:** There is a rich ecosystem of extensions and plugins that enhance functionality for whatever type of project you’re working on. 

<br> 

*** 

<br>

# How to use Jupyter Notebooks

Jupyter Notebook is an open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text. This is a great tool to develop and present code in a standardized text block format that is interactive and shareable. You can create code, mathematical formulas, data visualizations, and even freestyle text—all in Jupyter notebooks!

You will be using Jupyter notebooks to write, execute, and present your own code throughout this program. This reading will guide you through using your own notebook. Note, however, that for this certificate program you do not need to download any software. You can complete all activities with the tools provided on the Coursera platform.

# Jupyter Notebook

You can access Jupyter Notebook directly from your browser or download the desktop application onto your device to work with over 100 programming languages, including some you might already know like R and Python. There is [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/), which is the full suite of tools for working with computational notebooks. There is also [Jupyter Notebook](https://jupyter-notebook.readthedocs.io/en/stable/), which is a more streamlined and simplified tool that nonetheless offers powerful ways to perform interactive computing. Again, for this certificate program, we recommend working within the Jupyter Notebook interface provided by Coursera. Activities that use Jupyter notebooks will be labeled as labs, and you will find relevant instructions for each activity on its landing page.

# Why Jupyter Notebook?

Notebooks are particularly useful for working with data. Here are some ways that Jupyter notebooks excel:

1. **Modular/interactive computing:** You can write and execute individual chunks of code in small, manageable chunks, which are called cells. You can run a cell without necessarily having to run the whole notebook. This is especially helpful for data exploration and experimentation. Cells are also helpful with debugging, because they provide a user-friendly way to make a mistake, notice that you made the mistake, and iterate back to correct your mistake, without having to re-execute a whole script.
    
2. **Integration of code and documentation:** Notebooks allow you to combine code, textual explanations, and visualizations like charts, graphs, and tables—all in a single document. 
    
3. **Support for multiple languages:** The Advanced Data Analytics program will use Python, but Jupyter notebooks support many other languages, making them powerful and versatile.
    
4. **Data exploration and analysis:** The notebook simplifies working with data by offering tools to load, clean, analyze, and examine it in an elegant interface.
    
5. **Cloud-based services:** Many cloud computing platforms host Jupyter notebooks, which makes it easy to run and share notebooks without setting up a local environment. This is very useful for collaboration.
    
6. **Libraries and extensions:** There is a rich ecosystem of extensions and plugins that enhance functionality for whatever type of project you’re working on. 
    

# How to use Jupyter notebooks

Once you’ve opened a Jupyter notebook, it’s time to use it! Here are some tips to get started.

## Command/edit mode

Notebooks have two working modes: command mode and edit mode. Command mode is used to interact with the notebook as a whole and perform actions like adding, moving, and deleting cells. Edit mode is used to type code or markdown text into a particular cell. 

Command mode is indicated by a blue bar on the left side of the current cell.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/8c605b1f-b710-43de-a0de-b64050a63779)

Edit mode is indicated by a green bar on the left and also a thin green border around the active cell.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/7bdf2c52-efb3-4c61-aaf6-f431eb69f944)

To enter into edit mode, simply click into a cell to insert your cursor there or use the navigation arrows on your keyboard to select a cell and press Enter. To revert back to command mode, click anywhere outside the cell or press the escape key.

## Markdown mode

Jupyter notebooks allow you to toggle cells between coding mode and Markdown mode. Markdown is a markup language that lets you add formatting elements to plain text. It’s useful because it’s ubiquitous, future-proof, and platform independent. In Jupyter notebooks, Markdown text is used to provide written explanations, analysis, and context to explain the code and its output. In the following example, all of the text above In [41]: was written and formatted using Markdown.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/00f6815a-fca8-4a6d-b838-038a55f64580)

To toggle between code and Markdown mode, go to the menu at the top of the page and click where it says “Code.” Then, select “Markdown” from the dropdown menu that appears.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/df52ceee-3f35-4214-a032-8f0032e47ea8)

For more information about how to use Markdown, refer to [Markdown guide for basic syntax](https://www.markdownguide.org/basic-syntax/) and the [Markdown guide for extended syntax](https://www.markdownguide.org/extended-syntax/).

## Common actions

Most actions can be performed using both a mouse/graphic interface and keyboard shortcuts. Here are some of the most common actions.

### Add a new cell

- Click on Insert in the menu bar at the top of the notebook. Options are to insert a new cell above or below the current cell.
    
- Keyboard shortcuts (while in command mode):
    
    - **a:** Insert a cell above the current cell
        
    - **b:** Insert a cell below the current cell
        

### Delete a cell

- Use command mode to select a cell or group of cells.
    
- Click on Edit in the menu bar at the top of the notebook and select Delete Cells from the dropdown menu.
    
- Keyboard shortcut (while in command mode): 
    
    - **dd** (press D two times)
        

### Move a cell

- Use command mode to select a cell or group of cells.
    
- Click on the up arrow button or down arrow button in the menu bar at the top of the notebook to move the selected cell(s) up or down 
    

### Run a cell

- Select a cell and click the **Run** button in the menu bar at the top of the notebook.
    
- Keyboard shortcuts:
    
    - **Ctrl + Enter:** Run selected cell
        
    - **Shift + Enter:** Run selected cell and select next cell
        
    - **Alt + Enter:** Run selected cell and insert new cell below
        
- You can run cells from both command mode and edit mode
    

Press **h** while in command mode for a pop-up window with all available keyboard shortcuts. You can also check out [Jupyter Notebook interface components](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html) for more detailed descriptions of various notebook features.

# Troubleshooting

You will use Jupyter notebooks throughout the Advanced Data Analytics certificate program. At times, you might encounter difficulty accessing or running the notebook. Here are some troubleshooting steps to help you if this happens.

## Browser compatibility

Make sure your internet browser is updated regularly. It is best to use the latest version of Google Chrome, Firefox, or Microsoft Edge. If your browser is outdated or you are using a browser that is not supported by Coursera, you may encounter a problem. If your browser is up to date and you are using one of the browsers listed above and still encountering problems, try restarting your browser or clearing your browser’s cache and cookies. You can also use incognito mode, which prevents your browser from storing cookies and other temporary data.

## Internet connection

Coursera requires a stable internet connection. If you are experiencing problems starting or running a Jupyter notebook, your internet connection may be slow or unreliable. Some signs of an unstable internet connection may be pages failing to load, freezing labs, or the inability to type or enter commands within the lab environment. 

**Pro Tip:** If you are unable to complete a lab on one device, try using another device.

## Troubleshooting steps

To summarize, here are the troubleshooting steps to try if you encounter a problem with Jupyter notebooks in Coursera. 

1. Make sure you are using the latest version of a supported browser: Google Chrome, Firefox, or Microsoft Edge.
    
2. Restart your browser and clear your browser’s cache and cookies. You can also use incognito mode.
    
3. Check your internet connection and make sure it is stable. You can try restarting your router and modem to regain a stable connection.
    
4. Try restarting the lab again.
    

If all this fails, it’s possible that Coursera is performing maintenance or experiencing a service interruption. In that case, wait a little while and try again.

# Key takeaways

Jupyter Notebook provides a coding platform where you can develop and debug your own code. Knowing how to use and interact with notebooks will prepare you for upcoming activities where you will try out new Python skills and prepare for the end-of-course project. Python will be a great tool in your toolkit—it will open up more advanced analytics tools like machine learning and automated analysis. And, using Jupyter Notebook will be a great way to build your Python knowledge!

## Resources for more information

- [Jupyter Notebooks interface training](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html)
    
- [Jupyter software homepage](https://jupyter.org/)
    
- [Jupyter documentation](https://docs.jupyter.org/en/latest/)
    
- [Jupyter Notebooks cloud](https://jupyter.org/try-jupyter/retro/notebooks/?path=notebooks/Intro.ipynb) (online)
    
- [Jupyter community forum](https://discourse.jupyter.org/)
    
- [Jupyter notebooks community forum](https://discourse.jupyter.org/c/notebook/3)
    
- [Python community forum](https://www.python.org/community/forums/)
    
- [StackOverflow questions](https://stackoverflow.com/) (crowdsource forum to help solve problems)
    
- [Jupyter Notebooks installation](https://test-jupyter.readthedocs.io/en/latest/install.html)

<br> 

*** 

<br>

# More about object-oriented programming

**Note:** This reading contains only a brief introduction to object-oriented programming. A more detailed discussion about the nuances of object oriented programming is beyond the scope of this course.

Previously, we identified object-oriented programming as a programming paradigm that is based around objects, which can contain both data and code that manipulates that data. You may recall that a class is an object’s data type that bundles data and functionality together, and you’ve encountered some examples of this class-specific functionality in the form of methods and attributes. In this reading, you’re going to learn more about object-oriented programming and how it works. Although this certificate program will not require you to define your own classes, having a basic understanding of how this process works will be very helpful when you encounter these concepts along your learning journey.

## Review: Attributes and methods

Python classes are powerful and convenient because they come with built-in features that simplify common data analysis tasks. These features are known as attributes and methods.

- **Attribute**: A value associated with an object or class which is referenced by name using dot notation.
    
- **Method**: A function that belongs to a class and typically performs an action or operation. 
    

A simpler way of thinking about the distinction between attributes and methods is to remember that attributes are _characteristics_ of the object, while methods are _actions_ or _operations_.

For example, if the class were Spaceship, then attributes might be:

- name

- kind

- speed

- tractor_beam

These attributes could be accessed by typing:

- Spaceship.name

- Spaceship.kind

- Spaceship.speed

- Spaceship.tractor_beam

Notice that these characteristics are accessed using only a dot. 

On the other hand, methods of the Spaceship class might be:

- warp()

- tractor()

These methods could be used by typing:

- Spaceship.warp() 

- Spaceship.tractor()

Notice that methods are followed by parentheses, and it’s possible for them to take arguments. For example, Spaceship.warp(7) could change the speed of the ship to warp seven.

## Defining classes with unique attributes and methods

Python lets you define your own classes, each with their own special attributes and methods. This helps all different kinds of programmers to build reusable code that makes their work more efficient. You can even build the Spaceship class mentioned previously. The example, here, demonstrates how to do this.

**Note:** The following code block is not interactive.

```
   tractor_beam = 'off'

   # Instance attributes

   def __init__(self, name, kind):

       self.name = name

       self.kind = kind

       self.speed = None

  # Instance methods

   def warp(self, warp):

       self.speed = warp

       print(f'Warp {warp}, engage!')

   def tractor(self):

       if self.tractor_beam == 'off':

           self.tractor_beam = 'on'

           print('Tractor beam on.')

       else:

           self.tractor_beam = 'off'

           print('Tractor beam off')
```

For this course you don’t have to learn the syntax to create classes. Just notice that the class itself is defined first, and then indented beneath it are the attributes and methods. This is what it means when an attribute or method “belongs to a class.” Attributes and methods are defined in the code for that class. 

A class is like a blueprint for all things that share characteristics and behaviors. In this case, the class is Spaceship. There can be all different kinds of spaceships. They can have different names and different purposes. Whenever you create an object of a given class, you’re creating an **instance** of that class. This is also known as **instantiating** the class. In the code above, every time you instantiate an object of the Spaceship class it will start with its tractor beam set to off. The tractor beam is a class attribute. All instances of the Spaceship class have one. There are also instance attributes. These are attributes that you can assign when you instantiate the object. 

```
# Create an instance of the Spaceship class (i.e. "instantiate")

ship = Spaceship('Mockingbird','rescue frigate')

# Check ship's name

print(ship.name)

# Check what kind of ship it is

print(ship.kind)

# Check tractor beam status

print(ship.tractor_beam)

# Result

Mockingbird
rescue frigate
off
```

The next block of code uses the warp() method to set the warp speed to seven. Then it checks the current speed of the ship using the speed attribute.

```
# Set warp speed

ship.warp(7)

# Check speed

ship.speed

# Result

Warp 7, engage!
7
```

This final block of code uses the tractor() method to toggle the tractor beam. Then it checks the current status of the tractor beam using the tractor_beam attribute.

```
# Toggle tractor beam

ship.tractor()

# Check tractor beam status

print(ship.tractor_beam)

# Result

Tractor beam on.
on
```

This is just a basic example meant to demonstrate some of the fundamental ways that classes, attributes, and methods work and how they relate to each other, but classes can be very complex and have many attributes and methods. Depending on the work you’re doing as a data professional, knowledge about object-oriented programming will be helpful as you define your own classes, attributes, and methods to investigate the patterns, relationships, and meaning data holds. 

## Key takeaways

Classes comprise the core objects of Python, which is why Python is known as an object-oriented language. Class objects are powerful because they contain unique tools designed specifically for that class packaged within them. Methods are functions that belong to a class; they perform actions or operations, and they use parentheses. Attributes are values or characteristics associated with a class or class instance; they do not use parentheses. And, while there are many classes, attributes, and methods pre-built into Python, there is a high level of customization offered in the object-oriented programming paradigm.

<br> 

*** 

<br>


# Explore Python syntax

Python is a flexible programming language used in a wide range of fields, including software development, machine learning, and data analysis. Python is one of the most popular programming languages for data professionals, so getting familiar with its fundamental syntax and semantics will be useful for your future career. In this reading, you will learn about Python’s syntax and semantics, as well as where to find resources to further your learning.

## The Language of Python

People use language to communicate and give instructions to each other. Computers do the same thing, except computers use languages like Python, C++, and Java. So, in order to communicate instructions to the computer, programmers need to arrange ideas and concepts into a language it will understand.

Python syntax includes words that represent objects and commands, as well as punctuation that gives the words structure, hierarchy, and context. Together, the words and punctuation communicate ideas and processes; this is known as semantics. Semantics is the meaning conveyed by the syntax. The best way to learn syntax and semantics is through exposure. Practice coding and become familiar and comfortable with reading other people’s code. In addition, there are some general conventions that practitioners use to help maintain stylistic uniformity within the language. 

Coding languages are similar to spoken languages in that they have a way to classify words according to their function. For example, English sentences are composed of nouns, verbs, prepositions, etc.

Here are some of the basics:

- **Variables:** Represent data stored as strings, tuples, dictionaries, lists, and objects (note: future readings explain these categories)
    
    - Example: student_name
        
- **Keywords:** Special words that are reserved for specific purposes and that can only be used for those purposes
    
    - Examples:
        
        - in
            
        - not
            
        - or
            
        - for
            
        - while
            
        - return
            
- **Operators:** Symbols that perform operations on objects and values
    
    - Examples:
        
        - + Addition
            
        - - Subtraction
            
        - * Multiplication
            
        - / Division
            
        - ** Exponentiation
            
        - % Modulo (returns the remainder after a division). Example: 10 % 3 = 1
            
        - // Floor division (divides the first operand by the second operand and rounds the result down to the nearest integer. Example: 5 // 2 = 2
            
        - > Greater than (returns a Boolean of whether the left operand is greater than the right operand)
            
        - < Less than (returns a Boolean of whether the left operand is less than the right operand)
            
        - == Equality (returns a Boolean of whether the left operand is equal to the right operand)
            
- **Expressions:** A combination of numbers, symbols, and variables to compute and return a result upon evaluation
    
    - Example: [1, 2, 3] + [2, 4, 6]
        
- **Functions:** A group of related statements to perform a task and return a value
    
    - Example:
        

```
def to_celsius(x):

   '''Convert Fahrenheit to Celsius'''

   return (x-32) * 5/9

to_celsius(75)

# Result

23.88888888888889
```

- **Conditional statements:** Sections of code that direct program execution based on specified conditions
    
    - Example:
        

```
number = -4

if number > 0:

   print('Number is positive.')

elif number == 0:

   print('Number is zero.')

else:

   print('Number is negative.')

# Result

Number is negative.
```

As you’ll surely discover, Python generates syntax errors for incorrectly used keywords and syntax.

Example:

```
print(This will throw an error because I didn’t make it a string.)

# Result

Error on line 1:
    print(This will throw an error because I didn’t make it a string.)
                  ^
SyntaxError: invalid syntax
```

## Naming rules and conventions

When assigning names to objects, programmers adhere to a set of rules and conventions which help to standardize code and make it more accessible to everyone. Here are some naming rules and conventions that you should know:

- Names cannot contain spaces.
    
- Names may be a mixture of upper and lower case characters.
    
- Names can’t start with a number but may contain numbers after the first character.
    
- Variable names and function names should be written in snake_case, which means that all letters are lowercase and words are separated using an underscore. 
    
- Descriptive names are better than cryptic abbreviations because they help other programmers (and you) read and interpret your code. For example, student_name is better than sn. It may feel excessive when you write it, but when you return to your code you’ll find it much easier to understand.
    

Tim Peters, a Python programmer, wrote this now-famous “poem” of guiding principles for coding in Python:

**The Zen of Python**

Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

Special cases aren't special enough to break the rules.

Although practicality beats purity.

Errors should never pass silently.

Unless explicitly silenced.

In the face of ambiguity, refuse the temptation to guess.

There should be one—and preferably only one—obvious way to do it.

Although that way may not be obvious at first unless you're Dutch.

Now is better than never.

Although never is often better than *right* now.

If the implementation is hard to explain, it's a bad idea.

If the implementation is easy to explain, it may be a good idea.

Namespaces are one honking great idea -- let's do more of those!

Finally, it’s helpful to bookmark the [PEP 8 Style Guide for Python](https://peps.python.org/pep-0008/) so you can reference it as needed. This reading is limited in scope, and PEP 8 is a more exhaustive resource for style-related matters. PEP stands for Python Enhancement Proposals. These are a running catalog of ways to improve or standardize Python as a language. Because Python is open source, PEP offers a framework to guide developers and build consensus around ideas. It’s a useful and trusted resource.

## Key takeaways

Syntax and semantics are what give form and meaning to a language, including Python.  A large part of learning a new language is familiarizing yourself with its syntax and semantics. Much of this comes through exposure and practice, but there are a few guiding principles and resources that can help you along the way. If you learn the rules about naming objects and build a bank of resources that you can reference for guidance, you’ll surely make progress as a Python learner. As you get more familiar with Python, you’ll be able to communicate more efficiently with computers and do more with your data analysis tools!

## Resources for more information

Here are a few useful resources to help you get more familiar with Python:

- Python [Reference Library](https://docs.python.org/3/library/)
    
    - [Built-in Data types](https://docs.python.org/3/library/stdtypes.html)
        
    - [Built-in functions](https://docs.python.org/3/library/functions.html#built-in-functions)
        
- [Python operators](https://python-reference.readthedocs.io/en/latest/docs/operators/index.html)

<br> 

*** 

<br>

# Glossary terms from Module 1

# Terms and definitions from Course 2, Module 1

**Argument**: Information given to a function in its parentheses

**Assignment**: The process of storing a value in a variable

**Attribute**: A value associated with an object or class which is referenced by name using dot notation

**Cells**: The modular code input and output fields into which Jupyter Notebooks are partitioned

**Class**: An object’s data type that bundles data and functionality together

**Computer programming**: The process of giving instructions to a computer to perform an action or set of actions

**Data type**: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

**Dot notation**: How to access the methods and attributes that belong to an instance of a class

**Dynamic typing**: Variables that can point to objects of any data type

**Explicit conversion**: The process of converting a data type of an object to a required data type

**Expression**: A combination of numbers, symbols, or other variables that produce a result when evaluated

**Float**: A data type that represents numbers that contain decimals

**Immutable data type**: A data type in which the values can never be altered or updated

**Implicit conversion**: The process Python uses to automatically convert one data type to another without user involvement

**Integer**: A data type used to represent whole numbers without fractions

**Jupyter Notebook**: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

**Keyword**: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

**Markdown**: A markup language that lets the user write formatted text in a coding environment or plain-text editor 

**Method**: A function that belongs to a class and typically performs an action or operation

**Naming conventions**: Consistent guidelines that describe the content, creation date, and version of a file in its name

**Naming restrictions**: Rules built into the syntax of a programming language 

**Object**: An instance of a class; a fundamental building block of Python

**Object-oriented programming**: A programming system that is based around objects which can contain both data and code that manipulates that data

**Programming languages**: The words and symbols used to write instructions for computers to follow

**String**: A sequence of characters and punctuation that contains textual information

**Syntax**: The structure of code words, symbols, placement, and punctuation

**Typecasting:** Converting data from one type to another (see **explicit conversion**)

**Variable**: A named container which stores values in a reserved location in the computer’s memory

<br> 

*** 

<br>

# Module 2 Functions and conditional statements

# Reference guide: Functions

As you’ve been learning, functions are bodies of reusable code for performing specific processes or tasks. They help you do more work with less code. Function examples include: 

- A specific calculation or measurement, such as converting Fahrenheit to Celsius
    
- An inventory utility to iterate quantities and calculate the total cost of goods in stock
    
- Building a DataFrame from a series or dictionary data
    
- An application utility such as a spell checker
    

In this reading, you will learn how to define, build, and call functions. 

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

[Reference guide: Functions](https://docs.google.com/document/d/1Kxm7hv3w6ddQ6C2-m1ZNWD-EWte5QDlF6it0unmLjaw/template/preview?resourcekey=0-BeaGUzArCDKD0NLcRvzSGw) 

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

https://d3c33hcgiwev3.cloudfront.net/J6Hj-0oxSGefqbys50bYOA_55e9f56b4cd24427b1f1fb127c7551f1_Reference-guide_-Functions.docx?Expires=1710288000&Signature=RxpOqchi-7HHCLnPMcNK0wigmSVfP862ELFf~DUjU0TedwJIj6J8Ul0Bpv2y-wYZiLVFqECGLIpvVonXGsHt1VCBzBmz8sxsCicsbsaX51ub~oLMUFC8I0lvPnVazjTPFZ8v~-Ymep8V~3KaZKWtIrAld4g5HrnpYSFJQF~eMDc_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

## Function syntax

Define functions using the following syntax and format:

**Note:** The following code block is not interactive.

```
def my_function(parameters):

    '''

    Docstring.

    Summarize the function's behavior and explain its arguments and return values.

    '''

    code block

    return value
```

1. Begin with the def keyword followed by the function’s name, then put its parameters/arguments in parentheses, ending with a colon.
    
    1. Python convention is to use snake_case (lowercase words separated by underscores) for function names.
        
2. For important functions or functions whose purposes or operations are not very obvious, include a docstring. Write the docstring between three opening and closing quotation marks. 
    
    1. The docstring should be in the form of a command (e.g., “Add two numbers” as opposed to “Adds two numbers”).
        
    2. The docstring should summarize the function’s behavior and explain its arguments and return values.
        
    3. The docstring should be indented four spaces from the definition statement.
        
3. Write the body of the function. 
    
    1. All code should be indented at least four spaces from the definition statement, but there can be many levels of indentation depending on the complexity of the code. 
        
4. Finally, use a return statement to return a value or a print statement to print something to the console and complete the function. This line should also be indented four spaces.
    

## **return vs. print**

Sometimes the difference between return statements and print statements isn’t clear to new learners of Python. It’s important to understand what each action is and when to use it. Return statements give you a result that you can use for something else. It doesn’t have to be something that prints when the function is run. Print statements print something to the console and nothing more. Think of it like this: a return statement is like your brother going to the market and bringing you back a bag of potatoes. A print statement is like your brother going to the market, coming home, and telling you what kind of potatoes were for sale. With the return statement, you have some potatoes to cook. With the print statement, you just know what potatoes are available, but you don’t have any potatoes.

## **Functions vs. methods**

Functions and methods are very similar, but there are a few key differences. Methods are a specific type of function. They are functions that belong to a class. This means that you can use them—or “call” them—by using dot notation. 

**Method example:** 

```
my_string = 'The eagles filled the sky.'

my_string.split()

['The', 'eagles', 'filled', 'the', 'sky.']
```

The split method is a function that belongs to the string class. It splits strings on their whitespaces. 

Standalone functions do not belong to a particular class and can often be used on multiple classes. 

**Note:** The following code block is not interactive.

**Function example:**

```
 sum([6, 3])

9
```

You can review [Python’s list of built-in functions](https://docs.python.org/3/library/functions.html) and research how other people use them in the [Jupyter forum](https://discourse.jupyter.org/), [StackOverflow](https://stackoverflow.com/), and other online communities. 

## Resources for more information

For more information on functions, consider the Python [Reference Library](https://docs.python.org/3/library/), [Data types,](https://docs.python.org/3/library/stdtypes.html) [Functions](https://docs.python.org/3/library/functions.html#built-in-functions), [Symbols](https://wiki.python.org/moin/PythonGlossary?action=AttachFile&do=view&target=PySymbols.html)

- [Built-in functions](https://docs.python.org/3/library/functions.html#built-in-functions): 
    
    - [enumerate](https://docs.python.org/3/library/functions.html#enumerate)()
        
    - [isinstance](https://docs.python.org/3/library/functions.html#isinstance)()
        
    - [dict](https://docs.python.org/3/library/functions.html#func-dict)()
        
    - [type](https://docs.python.org/3/library/functions.html#type)() 
        
    - [len](https://docs.python.org/3/library/functions.html#len)()
        
    - [set](https://docs.python.org/3/library/functions.html#func-set)()
        
    - [zip](https://docs.python.org/3/library/functions.html#zip)()
        
- [Docstring conventions](https://peps.python.org/pep-0257/): PEP 257 guide to writing docstrings


<br> 

*** 

<br>

# Reference guide: Python operators

You’ve encountered many Python operators already. Many of them likely feel very familiar to you. After all, there’s nothing novel about addition and subtraction in Python. But there are many more operators than the ones used for basic arithmetic! Operators are characters that enact specific arithmetic, logical actions, or processes. Data professionals use operators all the time in their work, and they’re a rudimentary part of Python programming, so it’s important to learn them. This reading is a guide to the various operators available to you in Python.  

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Python operators](https://docs.google.com/document/d/1R6CU4cNKvztLqMNCferbGzYMk7KTRv0ZU4eGDlHJ_y8/template/preview)

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/5584Ds17S8OLKxJp_EKing_61b4a59ccbb44525b269496dc43a16f1_Reference-guide_-Python-operators.docx?Expires=1710288000&Signature=NFIDzUQ4pWr7MlBOczJ4SbKcFZ9L7H6fKCCXheBFOxcabir0YBK1gouzf29FoJ1Wrx~euAQH7Zu~FqrOjnOmuAegZcpfLP4iqp6EeAMMiTsztuANCH0ZSN6oRMxIWq9CjKm5f5cQ38EVjTHf2SaGzuPMhoX2P11x26dwyB2tVxg_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Comparators

In Python, you can use comparison operators to compare values. When a comparison is made, Python returns a Boolean result—True or False. Python uses the following comparators:

| **Operation**            | **Operator** |
| ------------------------ | ------------ |
| greater than             | >            |
| greater than or equal to | >=           |
| less than                | <            |
| less than or equal to    | <=           |
| not equal to             | !=           |
| equal to                 | ==           |

**Notes:** 

- The single equals sign (=) is reserved for assignment statements. If you use a single equal sign to make a comparison, the computer will return a **SyntaxError**.
    
- If you try to compare data types that aren’t compatible, like checking if a string is greater than an integer, Python will throw a **TypeError**. 
    

## Logical operators

Python also has three logical operators that can be combined with comparators to create more complex statements.

These operators are:

- and
    
    - evaluates to True only if both statements are true 
        
- or
    
    - evaluates to True if one or both of the statements are true
        
- not
    
    - reverses the evaluation
        
    - If the statement evaluates to True, returns False; if the statement evaluates to False, returns True
        

Examples: 

```
x = 3

my_list = [3, 4, 6, 10]

print(x < 3 and x != 0)

print(x >= len(my_list) or x == min(my_list))

print(x not in my_list)

# Result

False
True
False
```

## Arithmetic operators

Python is also capable of performing mathematical operations using a set of built-in operators. These arithmetic operators are:

|**Operation**|**Operator**|**Example**|
|---|---|---|
|Addition|+|[IN]  5 + 2<br><br>[OUT] 7|
|Subtraction|-|[IN] 5 - 2<br><br>[OUT] 3|
|Multiplication|*|[IN] 5 * 2<br><br>[OUT] 10|
|Division|/|[IN] 5 / 2<br><br>[OUT] 2.5|
|Modulo (the remainder of a division)|%|[IN] 5 % 2 <br><br>[OUT] 1|
|Exponentiation|**|[IN] 5 ** 2<br><br>[OUT] 25|
|Floor division<br><br>(the number of times the denominator can fully go into the numerator)|//|[IN] 5 // 2<br><br>[OUT] 2|

There are many other mathematical operations that can be performed in Python using functions from special libraries, which you’ll learn about later. Python uses a core set of operators to make comparisons, perform logical operations, and compute arithmetic operations. These operators can be combined in statements to perform an infinite number of tasks and operations.

<br> 

*** 

<br>

# Reference guide: Conditional statements

Conditional statements are an essential part of programming. They allow you to control the flow of information based on certain conditions. In Python, if, elif, and else statements are used to implement conditional statements. Using conditional statements to branch program execution is a core part of coding for most data professionals, so it’s important to understand how they work. This reading is a reference guide to conditional statements.

## Save this course item

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Conditional statements](https://docs.google.com/document/d/1DnAA9MY1xW-Xw2UrBaAFbHNkkfQxi1ZAYzYazwiCaHo/template/preview?resourcekey=0-nyt9oGjsbubU0Ky8oeff5Q#heading=h.xr97bf74ctnq) 

OR

If you don’t have a Google account, you can download the item directly from the following attachment.

[File](https://d3c33hcgiwev3.cloudfront.net/8AjHHn8BQz2FjQJu6_ZseQ_15fb6f2e66ff4f08b2accb3bf3cabbf1_Reference-guide_-Conditional-statements.docx?Expires=1710288000&Signature=ki8i95EbyneewyKLmetrL6xJXKzzfnkJroXcYsLYU8q6u4YjvLAMDd7QgTsTzqXPCDDC~NEkOGeZqYYYd-XmG~4B012B9i~2XVTOKzkOWnrpKVD2qyoT9f0iP43qgg9xt9GWv6jRvaMRDcztfOxK-K3gfZ0KKPJdsSQlqEMfZ5I_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Conditionals syntax

In earlier videos, you learned some built-in Python operators that allow you to compare values, and some logical operators that you can use to combine values. You also learned how to use operators in if-elif-else blocks. 

**Note**: The following code block is not interactive.

The basic syntax of if-elif-else statements in Python is as follows:

```
if condition1:

   # block of code to execute if the condition evaluates to True

elif condition2:

   # block of code to execute if condition1 evaluates to False

   # and condition2 evaluates to True

else:

   # block of code to execute if BOTH condition1 and condition2

   # evaluate to False
```

Here, condition1 and condition2 are expressions that evaluate to either True or False. If the condition in the if statement is true, then the block of code that follows is executed. Otherwise, it is skipped.

The elif statement stands for “else if,” and it is used to specify an alternative condition to check if the first condition is false. You can have any number of elif statements in your code. If the preceding condition is false and the elif condition is true, then the block of code that follows the elif statement is executed.

The else statement is used to specify what code to execute if both the if statement and any subsequent elif statements are false. 

Here is an example that uses all three kinds of statements:

```
x = 8

if x > 5:

   print('x is greater than five')

elif x < 5:

   print('x is less than five')

else:

   print('x is equal to five')

# Result

x is greater than five
```

Some important things to note about conditional statements in Python:

- The elif and else statements are optional. You can have an if statement by itself.
    
- You can have multiple elif statements.
    
- You can only have one else statement, and only at the end of your logic block.
    
- The conditions must be an expression that evaluates to a Boolean value (True or False).
    
- Indentation matters! The code associated with each conditional statement must be indented below it. The typical convention for data professionals is to indent four spaces. Indentation mistakes are one of the most common causes of unexpected code behavior.

<br> 

*** 

<br>

# Glossary terms from module 2

# Terms and definitions from Course 2, Module 2

**Algorithm**: A set of instructions for solving a problem or accomplishing a task

**Boolean**: A data type that has only two possible values, usually true or false

**Branching**: The ability of a program to alter its execution sequence

**Comparator**: An operator that compares two values and produces Boolean values (True/False)

**def**: A keyword that defines a function at the start of the function block

**Docstring**: A string at the beginning of a function’s body that summarizes the function’s behavior and explains its arguments and return values

**elif**: A reserved keyword that executes subsequent conditions when the previous conditions are not true 

**else**: A reserved keyword that executes when preceding conditions evaluate as False

**Function**: A body of reusable code for performing specific processes or tasks

**if**: A reserved keyword that sets up a condition in Python

**Logical operator**: An operator that connects multiple statements together and performs complex comparisons

**Modularity**: The ability to write code in separate components that work together and that can be reused for other programs

**Modulo**: An operator that returns the remainder when one number is divided by another

**Refactoring**: The process of restructuring code while maintaining its original functionality

**return**: A reserved keyword in Python that makes a function produce new results which are saved for later use

**Reusability**: The capability to define code once and using it many times without having to rewrite it

**Self-documenting code**: Code written in a way that is readable and makes its purpose clear

# Terms and definitions from the previous module

## A

**Argument**: Information given to a function in its parentheses

**Assignment**: The process of storing a value in a variable

**Attribute**: A value associated with an object or class which is referenced by name using dot notation

## C

**Cells**: The modular code input and output fields into which Jupyter Notebooks are partitioned

**Class**: An object’s data type that bundles data and functionality together

**Computer programming**: The process of giving instructions to a computer to perform an action or set of actions

## D

**Data type**: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

**Dot notation**: How to access the methods and attributes that belong to an instance of a class

**Dynamic typing**: Variables that can point to objects of any data type

## E

**Explicit conversion**: The process of converting a data type of an object to a required data type

**Expression**: A combination of numbers, symbols, or other variables that produce a result when evaluated

## F

**Float**: A data type that represents numbers that contain decimals

## I

**Immutable data type**: A data type in which the values can never be altered or updated

**Implicit conversion**: The process Python uses to automatically convert one data type to another without user involvement

**Integer**: A data type used to represent whole numbers without fractions

## J

**Jupyter Notebook**: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

## K

**Keyword**: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

## M

**Markdown**: A markup language that lets the user write formatted text in a coding environment or plain-text editor 

**Method**: A function that belongs to a class and typically performs an action or operation

## N

**Naming conventions**: Consistent guidelines that describe the content, creation date, and version of a file in its name

**Naming restrictions**: Rules built into the syntax of the language itself that must be followed

## O

**Object**: An instance of a class; a fundamental building block of Python

**Object-oriented programming**: A programming system that is based around objects which can contain both data and code that manipulates that data

## P

**Programming languages**: The words and symbols used to write instructions for computers to follow

## S

**String**: A sequence of characters and punctuation that contains textual information

**Syntax**: The structure of code words, symbols, placement, and punctuation

## V

**Variable**: A named container which stores values in a reserved location in the computer’s memory

# Module 3 Loops and strings



<br> 

*** 

<br>


# Loops, break, and continue statements

You’ve learned about while loops in Python and have explored some examples. While loops are useful because they allow you to perform an action or evaluation repeatedly until a given condition or requirement is met, and then they stop. This is an important process in computer programming, not just in Python, but in most other languages too. Data professionals use while loops to process data, so it’s important for you to familiarize yourself with them as you grow your skills. This reading is a review of the fundamental concepts of while loops.

## While loop syntax

A while loop is a control structure that allows you to repeatedly execute a block of code for as long as a certain condition is true.

**Note**: The following code block is not interactive.

The basic syntax of a while loop is as follows:

```
while condition:

   # Code block to execute
```

The condition is a Boolean expression that is evaluated at the beginning of each iteration of the loop. If the condition is true, the code block executes. After the code block executes, the condition is evaluated again. This process continues until the condition is false, at which point the loop terminates and the program continues with the next statement after the loop.

Here is an example of a basic while loop:

```
x = 1

while x < 100:

   print(x)

   x = x*2

# Result

1
2
4
8
16
32
64
```

In this example, x equals one when the loop begins. Because x is less than 100, the program prints the value of x, then multiplies x by two. Then the condition is checked again, and because it is still True, the code inside the loop executes again. This process continues until x becomes 128, at which point the condition becomes False and the loop terminates.

## Infinite loops

Be careful with while loops because if you make a mistake with your logic or syntax, it could result in an infinite loop that never terminates. In the previous example, if x = x*2 were accidentally not indented to be in the body of the while loop, the loop would reach the print statement and cycle back to check the conditional statement, which of course would still be true because the value of x would never change from one.

If you get stuck in an infinite loop, don’t worry. You can break out of it by interrupting the kernel. There are several ways to do this:

1. Use the stop button in the menu at the top of the notebook.
    

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/1b394c95-11db-4dad-b461-79099ecde5d9)

2. Go to Kernel in the menu bar at the top of the notebook and select Interrupt from the drop-down menu.

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/47221e6a-c528-4f6c-89f4-58004b1a2549)

3. While in command mode, press i twice.

## break & continue

It is possible to end a loop even if the conditional statement is still true. To do this, use a break statement.

Here’s an example:

```
x = 1

i = 0

while x < 100:

   if i == 5:

       break

   print(i, x)

   x = x*2

   i += 1

# Result

0 1
1 2
2 4
3 8
4 16
```

In this example, there is a variable i that acts as a counter. For each iteration of the loop, the program:

1. Checks if x is less than 100.
    
2. If it is, then the program checks if i equals five.
    
3. If it does, the loop terminates because of the break statement. Otherwise, it prints the values of both i and x, doubles the value of x, and increments the value of i by one.
    
4. Repeats until x ≥ 100 or i = 5. In this case, the loop breaks when i becomes 5.
    

It’s also possible to skip an iteration of the loop without executing the rest of the code inside the loop for the current iteration. To do this, use a continue statement.

Here’s an example:

```
i = 0

while i < 10:

    if i % 3 != 0:

        print(i)

        i += 1

        continue

    i += 1

# Result 

1
2
4
5
7
8
```

This example is a loop that prints all the numbers from zero through 9 that are not divisible by three. For each iteration of the loop, the program:

1. Checks if i is less than 10.
    
2. If it is, then the program uses the modulo operator to check if i is evenly divisible by three.
    
3. If it is not, then the program prints i, increments the value of i by one, _and then cycles back to the beginning_ to check that i is less than 10. This happens because of the continue statement. The final i += 1 does not execute, thus avoiding a double incrementation of i.
    
4. But if step 2 evaluates i as evenly divisible by three, nothing in the if block executes (so there’s no print statement) and i is incremented by one.
    
5. Repeats until i becomes 10. 
    

## Key takeaways

A while loop allows you to repeatedly execute a block of code while a certain condition is true. You can use the break statement to exit the loop prematurely, and the continue statement to skip to the next iteration of the loop without executing the rest of the code in the current iteration.

<br> 

*** 

<br>



# For loops

You’ve learned about for loops in Python and have explored some examples. For loops are like while loops, but instead of looping continuously until a condition is met, for loops iterate over each element of an iterable sequence, allowing you to perform an action or evaluation with each iteration. This is an important process in computer programming, not just in Python, but in most other languages too. Data professionals use for loops to process data, so it’s important for you to familiarize yourself with them as you grow your skills. This reading is a review of the fundamental concepts of for loops.

## For loop syntax

A for loop is a control structure that allows you to execute a block of code the same number of times as there are elements in an iterable sequence. You’ll learn more about iterable sequences later in this course, but some examples of iterable data types include:

Strings: ‘chimichurri’

Lists: [1, 2, 3, 4, 5, 6]

Tuples: (1, 2, 3, 4, 5)

Dictionaries: {‘Name’: ‘Anita’, ‘Age’: 77} 

Sets: {1, 4, 14, 33}

**Note**: The following code block is not interactive.

The basic syntax of a for loop is as follows:

```
for item in iterable_sequence:

   # Code block to be executed for each value in iterable_sequence
```

The iterable_sequence variable can be any iterable data type, and item is a variable whose name is arbitrary —you decide it. However, there are some conventions that you’ll encounter when naming this variable. For example, if you’re iterating over characters in a string, you’ll frequently encounter the variable char. If you’re iterating over a list of numbers, you’ll find n or num. It’s helpful to give this variable a name so readers of your code understand what kind of information is being looped over. So, for a variable called names that contains a list of people’s names, you might write: for name in names:.

A note about the behavior of this variable — its value is reassigned for each iteration of the loop, and it persists even after the loop terminates.

Here’s an example:

```
num = 5

y = [1, 2, 3]

for num in y:

   print(num)

print(num)

# Result 

1
2
3
3
```

Notice that num exists as a variable before the for loop begins. The for loop’s first iteration reassigns its value with that of the first element in the sequence. This reassignment occurs with each iteration of the loop. When the loop terminates, the variable persists, and it contains the value it had after the final iteration of the loop.

## The range() function

The for loop allows you to create a loop that performs exactly the number of iterations needed for the data structure you’re looping over. In other words, whether your iterable sequence contains two, 1,000, or a million elements, you can use the same syntax and don’t have to specify the number of iterations you want. However, sometimes you need to perform a task a set number of times, but you don’t already have an iterable object to loop over. Or, sometimes you need to generate a known, regular sequence of numbers. This is where the range() function is useful.

The range() function is a function that takes three arguments: start, stop, step. Its output is an object belonging to the range class. If you only include one argument, it will be interpreted as the stop value. The start and step values by default will be zero and one, respectively. If you include two arguments, they will be interpreted as the start and stop values (again, with step being one by default). Note that the stop value is not included in the range that is returned.

Here are some examples:

**A.**

```
for i in range(3):

   print(i)

# Result

0
1
2
```

**B.**

```
for n in range(2, 5):

   print(n)

# Result

2
3
4
```

**C.**

```
for even_num in range(2, 11, 2):

   print(even_num)

# Result

2
4
6
8
10
```

You’ll find that the range() function is very useful, for example, when creating numbered lists or performing operations on certain indices of an object. You’ll learn more about indexing later.

## Nested loops

Sometimes you’ll need to extract information from nested structures—for example, from a list of lists. One way of doing this is by using nested loops. A nested loop is a loop inside of another loop. You can have an infinite number of nested loops, but it becomes more confusing to read and understand the more nested loops you add.

Here’s an example of one loop nested in another:

```
students = [['Igor', 'Sokolov'], ['Riko', 'Miyazaki'], ['Tuva', 'Johansen']]

for student in students:

   for name in student:

       print(name)

   print()

# Result

Igor
Sokolov

Riko
Miyazaki

Tuva
Johansen
```

In this example, the students variable contains a list of three lists. Each inner list contains two elements: a given name and a surname. The first for loop iterates over the inner lists. The second (nested) for loop iterates over each name in each inner list and prints the name. After each iteration of the outer loop, the program uses an empty print statement to print a new line.

## Key takeaways

A for loop allows you to execute a block of code the same number of times as there are elements in an iterable sequence. The range() function is useful for creating a defined iterable sequence. And nested loops are loops within loops that give you even greater power and control over how your code may execute. These are powerful tools that can be used in many different ways to solve a variety of problems that you’ll encounter as a data professional.


<br> 

*** 

<br>




# String indexing and slicing

As you know, strings are an important class of data because they represent text. Data professionals encounter strings all the time, so it’s important to become familiar with different ways of manipulating and working with them. This reading will review the string formatting techniques you’ve learned and also introduce you to regular expressions.

## String formatting

Indexing refers to accessing a single element of a sequence by its position. _In Python, the first element of any sequence has an_ **index of zero.** This means Python uses zero-based indexing. Numerous other programming languages also use zero-based indexing, but not all of them do. Some languages use one-based indexing, such as R, Julia, and SAS. 

Use square brackets to perform indexing. Here are some examples:

```
my_string = 'Mississippi half-step'

print(my_string[0])

my_list = [1, 'unladen', 'swallow']

print(my_list[1])

print(my_list[-1])

# Result

M
unladen
swallow
```

In these examples, there are two sequence variables: a string and a list. Indexing is used to access the character at index zero of the string, which is its first character—M. The list is selected at index one, which contains the word “unladen.” The list is also selected at its final position using negative indexing. 

**Note:** If you try to select an index that is out of range of what the object contains, you’ll get an IndexError. 

```
my_list = [1, 'unladen', 'swallow']

my_list[3]

# Result

Error on line 2:
    my_list[3]
IndexError: list index out of range
```

## Slicing

Slicing refers to accessing a range of elements from a sequence. Use square brackets containing two indices separated by a colon.

Here are some examples:

```
new_string = 'pining for the fjords'

print(new_string[0:3])

print(new_string[:3])

# Result

pin
pin
```

These two examples, each with slightly different syntax, are being used to produce the same result. Notice two things: (1) the resulting slice includes the starting index and excludes the ending index; (2) when the starting index is omitted it’s implied to be zero, as shown in the second print line. 

The process follows the same logic when the ending index is omitted:

```
new_string = 'pining for the fjords'

print(new_string[6:21])

print(new_string[6:])

print(len(new_string))

# Result

 for the fjords
 for the fjords
21
```

Again, there are two statements that are syntactically different but still produce the same substring. When the ending index is omitted, its implied value is the length of the sequence.  

Finally, the code will throw an IndexError if you try to index a sequence at an index number outside the scope of the elements; this is not the case for slicing.

For example:

```
new_string = 'pining for the fjords'

print(new_string[6:100])

# Result

 for the fjords
```

Although the ending index was 100—far beyond the scope of the indices in the string—the computer returned a substring that ended with the string’s final element. 

## Key takeaways

Indexing and slicing are powerful tools in Python that allow you to access specific elements or parts of a sequence. Both indexing and slicing use square brackets. Remember that in a slice the starting index is inclusive and the stopping index is exclusive, and that negative indices count from the end of the sequence. With these tools, you can manipulate strings and other iterable sequences to perform a wide variety of operations, making you a more proficient data professional.

<br> 

*** 

<br>



# String formatting and regular expressions

As you’ve learned, strings are a crucial class of data because they represent textual information. Data professionals encounter strings all the time, so it’s important to become familiar with different ways of manipulating and working with them. This reading will review the string formatting techniques you’ve learned, and also introduce you to regular expressions. 

## String formatting

String formatting uses the format() method, which belongs to the string class. This method formats and inserts specific substrings into designated places within a larger string. It’s useful when you have reusable template text into which you want to insert specific changeable values, for example. The format() method is also useful when assigning the strings used to label charts and graphs you make.

Here’s an example:

```
x = 'values'

y = 100

print('''String formatting lets you insert {} into strings.

They can even be numbers, like {}.'''.format(x, y))

Reset

String formatting lets you insert values into strings.
They can even be numbers, like 100.
```

Notice the syntax. The format() function inserts its arguments into the braces within the string that it’s attached to. The order of insertion follows the order of the arguments. Also, this example includes a helpful trick. Sometimes you’ll encounter a very long string. Many editors will allow the string to keep extending to the right on a single line. This is impractical unless you have a very wide monitor, but 79 characters is a conventional maximum length for a single line of Python code. Enclosing your string in triple quotes lets you break the string over multiple lines.

The format() function can also insert values into braces using explicitly assigned keyword names, which allow you to mix up the order of the function’s arguments without changing the order of their insertion into the final string.

For example:

```
var_a = 'A'

var_b = 'B'

print('{a}, {b}'.format(b=var_b, a=var_a))

Reset

A, B
```

Because the arguments were named, it didn’t matter that they were entered with var_b first and var_a last; they still were inserted into the string in the order specified.

You can also include the arguments’ index numbers within the braces to indicate which arguments get inserted in specific spots:

```
var_a = 'A'

var_b = 'B'

print('{1}, {0}'.format(var_a, var_b))

print('{0}, {1}'.format(var_a, var_b))

Reset

B, A
A, B
```

You can have as many arguments as you want:

```
print('{}, {}, {}, {}, {}, {} ...'.format(1, 2, 3, 4, 5, 6))

Reset

1, 2, 3, 4, 5, 6 ...
```

And you can repeat arguments’ indices:

```
print('{0}{1}{0}'.format('abra', 'cad'))
```

Reset

abracadabra

The string format() method is a versatile and convenient way to take values that are stored in different variables and insert them into a string.

## **Literal string interpolation (f-strings)**

Another string formatting technique that you’ll often encounter when using Python version 3.6+ is literal string interpolation, also known as f-strings. F-strings further minimize the syntax required to embed expressions into strings. They’re called f-strings because the expressions always begin with f (or F—they’re the same).

For example:

```
var_a = 1

var_b = 2

print(f'{var_a} + {var_b}')

print(f'{var_a + var_b}')

print(f'var_a = {var_a} \nvar_b = {var_b}')

Reset

1 + 2
3
var_a = 1 
var_b = 2
```

In these examples, the braces still function as the way to indicate where values should be inserted into the string, but they allow you to make the insertion directly, without having to call the format() method.

## **Float formatting options**

In addition to inserting expressions into strings, string formatting can format their appearance. There are too many options to list here, but the [Python string documentation](https://docs.python.org/3/library/string.html) is a good place to review these techniques. Here are some of the most useful.

### **To use these options, build your expression within braces as follows.**

1. The float variable is what’s being formatted
    
2. A colon (:) separates what’s being formatted from the syntax used to format it
    
3. . number indicates the desired precision
    
4. A letter indicates the presentation type
    

![image](https://github.com/kemda2/Google-Advanced-Data-Analytics/assets/19648132/02a8ed3b-fd9d-4804-9d94-08daf6759e11)

Example:

```
num = 1000.987123

f'{num:.2f}'

Reset

1000.99
```

This example uses the f presentation type to specify that the number contained in the num variable should be rounded to two places beyond the decimal.

Here are some of the most common presentation types:

|**Type**|**Meaning**|
|---|---|
|'e'|Scientific notation. For a given precision p, formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, e uses a precision of 6 digits after the decimal point for [float](https://docs.python.org/3/library/functions.html#float), and shows all coefficient digits for [decimal](https://docs.python.org/3/library/decimal.html#decimal.Decimal).|
|'f'|Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point.|
|'%'|Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign.|

Here are some examples:

```
num = 1000.987123

print(f'{num:.3e}')

decimal = 0.2497856

print(f'{decimal:.4%}')

Reset

1.001e+03
24.9786%
```

## **String methods**

As one of the primary object classes in Python, strings have many built-in methods designed to facilitate working with them. There are too many of these methods to cover all of them here in depth, but some of the most useful include:

str.count(sub[, start[, end]])

Return the number of non-overlapping occurrences of substring sub in the range [start , end].

```
my_string = 'Happy birthday'

print(my_string.count('y'))

print(my_string.count('y', 2, 7))

Reset

2
1
```

### str.find(sub)

Return the lowest index in the string where substring sub is found. Return -1 if sub is not found.

```
my_string = 'Happy birthday'

my_string.find('birth')

Reset

6
```

### str.join()

Return a string which is the concatenation of the strings in iterable. The separator between elements is the string providing this method.

```
separator_string = ' '

iterable_of_strings = ['Happy', 'birthday', 'to', 'you']

separator_string.join(iterable_of_strings)

Reset

Happy birthday to you
```

### str.partition(sep)

Split the string at the first occurrence of sep , and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.

```
my_string = 'https://www.google.com/'

my_string.partition('.')

Reset

('https://www', '.', 'google.com/')
```

### str.replace(old, new[, count])

Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.

```
my_string = 'https://www.google.com/'

my_string.replace('google', 'youtube')

Reset

https://www.youtube.com/
```

### str.split([sep])

Return a list of the words in the string, using sep (optional) as the delimiter string. If no sep is given, whitespace characters are used as the delimiter. Any number of consecutive whitespaces would indicate a split point, so ' ' (a single whitespace) would split the same way as ' ' (two or more whitespaces).

```
my_string = 'Do you know the muffin man?'

my_string.split()

Reset

['Do', 'you', 'know', 'the', 'muffin', 'man?']
```

Note that some of these methods have additional optional parameters. This reading covers only the most rudimentary ones. Reference the full [string methods documentation](https://docs.python.org/2/library/stdtypes.html#string-methods) for more information on these functions and other methods not included here.

## Regular expressions

Regular expressions, also known as regex, refer to techniques that advanced data professionals use to modify and process string data. This certificate program will not require you to use regular expressions in your work, but it’s important for you to be aware of the concept. As always, you’re encouraged to explore regular expressions on your own. 

Regex works by matching patterns in Python. It allows you to search for specific patterns of text within a string of text. Regex is used extensively in web scraping, text processing and cleaning, and data analysis. 

The first step in working with regular expressions is to import the re module. This module provides the tools necessary for working with regular expressions. Once you have imported the module, you can start working with regular expressions.

**Note**: The following code block is not interactive.

The basic syntax for a regular expression is:

```
import re

pattern = 'regex_pattern'

match = re.search(pattern, string)
```

Here is a basic example:

```
import re

my_string = 'Three sad tigers swallowed wheat in a wheat field'

re.search('wall', my_string)

Reset

<_sre.SRE_Match object; span=(18, 22), match='wall'>
```

This example returns a match object that contains information about the search. In this case, it tells you that the substring ‘wall’ does occur in the string from indices 18–22. 

Regex is especially useful because it allows you a very high degree of customization when performing your searches.

Here’s another example:

```
import re

my_string = 'Three sad tigers swallowed wheat in a wheat field'

re.search('[bms]ad', my_string)

Reset

<_sre.SRE_Match object; span=(6, 9), match='sad'>
```

This example will search for “bad,” “mad,” and “sad.” Again, these are very basic examples.

Regex has a large catalogue of special expressions that let you search for substrings that will only match if, for example, they are followed by certain characters, or if they don’t contain a certain set of characters. It can get very complex. Depending on the work you do as a data professional, you may find yourself exploring regular expressions to analyze and process your data.

## Key takeaways

String formatting is the process of inserting specific substrings into designated places within a larger string. Often, the inserted substrings get processed and formatted a certain way. There are multiple ways of using string formatting to help you process strings. These include the format() method, literal string interpolations—or f-strings—and regular expressions, also known as regex. The methods you use will depend on what your data demands and your own personal preferences, but it’s important to be familiar with the most common techniques used by data professionals.

# Glossary terms from module 3

# Terms and definitions from Course 2, Module 3

break: A keyword that lets a user escape a loop without triggering any ELSE statement that follows it in the loop

Concatenate: To link or join together

Escape character: A character that changes the typical behavior of the characters that follow it

For loop: A piece of code that iterates over a sequence of values

format(): A string method that formats and inserts specific substrings into designated places within a larger string

index(): A string method that outputs the index number of a character in a string

Indexing: A way to refer to the individual items within an iterable by their relative position

Iterable: An object that’s looped, or iterated, over

Iteration: The repeated execution of a set of statements, where one iteration is the single execution of a block of code

Loop: A block of code used to carry out iterations 

range(): A Python function that returns a sequence of numbers starting from zero, increments by 1 by default, and stops before the given number 

String slice: A portion of a string that can contain more than one character; also referred to as a substring 

While loop: A loop that instructs the computer to continuously execute the code based on the value of a condition

Terms and definitions from previous modules

A

Algorithm: A set of instructions for solving a problem or accomplishing a task

Argument: Information given to a function in its parentheses

Assignment: The process of storing a value in a variable

Attribute: A value associated with an object or class which is referenced by name using dot notation

B

Boolean: A data type that has only two possible values, usually true or false

Branching: The ability of a program to alter its execution sequence

C

Cells: The modular code input and output fields into which Jupyter Notebooks are partitioned

Class: An object’s data type that bundles data and functionality together

Comparator: An operator that compares two values and produces Boolean values (True/False)

Computer programming: The process of giving instructions to a computer to perform an action or set of actions

D

Data type: An attribute that describes a piece of data based on its values, its programming language, or the operations it can perform

def: A keyword that defines a function at the start of the function block

Docstring: A string at the beginning of a function’s body that summarizes the function’s behavior and explains its arguments and return values

Dot notation: How to access the methods and attributes that belong to an instance of a class

Dynamic typing: Variables that can point to objects of any data type

E

elif: A reserved keyword that executes subsequent conditions when the previous conditions are not true 

else: A reserved keyword that executes when preceding conditions evaluate as False

Explicit conversion: The process of converting a data type of an object to a required data type

Expression: A combination of numbers, symbols, or other variables that produce a result when evaluated

F

Float: A data type that represents numbers that contain decimals

Function: A body of reusable code for performing specific processes or tasks

I

if: A reserved keyword that sets up a condition in Python

Immutable data type: A data type in which the values can never be altered or updated

Implicit conversion: The process Python uses to automatically convert one data type to another without user involvement

Integer: A data type used to represent whole numbers without fractions

J

Jupyter Notebook: An open-source web application for creating and sharing documents containing live code, mathematical formulas, visualizations, and text

K

Keyword: A special word in a programming language that is reserved for a specific purpose and that can only be used for that purpose

L

Logical operator: An operator that connects multiple statements together and performs complex comparisons

M

Markdown: A markup language that lets a user write formatted text in a coding environment or plain-text editor 

Method: A function that belongs to a class and typically performs an action or operation

Modularity: The ability to write code in separate components that work together and that can be reused for other programs

Modulo: An operator that returns the remainder when one number is divided by another

N

Naming conventions: Consistent guidelines that describe the content, creation date, and version of a file in its name

Naming restrictions: Rules built into the syntax of a programming language 

O

Object: An instance of a class; a fundamental building block of Python

Object-oriented programming: A programming system that is based around objects which can contain both data and code that manipulates that data

P

Programming languages: The words and symbols used to write instructions for computers to follow

R

Refactoring: The process of restructuring code while maintaining its original functionality

return: A reserved keyword in Python that makes a function produce new results which are saved for later use

Reusability: The capability to define code once and using it many times without having to rewrite it

S

Self-documenting code: Code written in a way that is readable and makes its purpose clear

String: A sequence of characters and punctuation that contains textual information

Syntax: The structure of code words, symbols, placement, and punctuation

V

Variable: A named container which stores values in a reserved location in the computer’s memory

# Module 4 Data structures in Python

<br> 

*** 

<br>



# Reference guide: Lists

You’ve been learning that lists are important data structures in Python. A list is a data structure that helps store and manipulate an ordered collection of items. These items can be of any data type such as integers, floats, strings, and even other lists. Because they are so versatile, data professionals and all Python programmers use lists every day, so it’s important to be familiar with how they work. This reading is a reference guide for lists designed to help you as you learn Python.

## **Save this course item**

You may want to save a copy of this guide for future reference. You can use it as a resource for additional practice or in your future professional projects. To access a downloadable version of this course item, click the following link and select “Use Template.” 

Reference guide: [Lists](https://docs.google.com/document/d/1yZoljX91vuOG2dXAekx0lf3w1DxX1z1NyMtcUSdYEzQ/template/preview#heading=h.387z4nt1u8b3)

OR

If you don’t have a Google account, you can download the item directly from the attachment below.

[File](https://d3c33hcgiwev3.cloudfront.net/EQNOVNiJRyqtZY1tk0mulQ_cf32c9e13cc0478db1b344c7fe927df1_Reference-guide_-Lists.docx?Expires=1710374400&Signature=WaJDrrIENowD87Zbhx2EyRieMBRVxrA0ZOdpoDn~MQf74hvwmXJ7dI860BMbeWQCzfz1XeRud4k9P2Ff6jDttynEckgy-n5rVEznj8VWoxoMZbRScQkepHx4gZYN8a7xo-YtaBVblG5gDIg01KqAIclYDQ0~pqR5ZTVuKWnJ~ms_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Create a list

There are two main ways to create lists in Python:

- Square brackets: []
    
- The list function: list()
    

When instantiating a list using brackets, separate each element with a comma.

For example, the following code creates a list of strings:

```
list_a = ['olive', 'palm', 'coconut']

print(list_a)

Reset

['olive', 'palm', 'coconut']
```

You can also create a list of integers:

```
list_b = [8, 6, 7, 5, 3, 0, 8]

print(list_b)

Reset

[8, 6, 7, 5, 3, 0, 8]
```

Or a list of mixed data types:

```
list_c = ['Abidjan', 14.2, [1, 2, None], 'Zagreb']

print(list_c)

Reset

['Abidjan', 14.2, [1, 2, None], 'Zagreb']
```

To create an empty list, use empty brackets or the list() function:

```
empty_list_1 = []

empty_list_2 = list()

Reset

[]
```

## Indexing and slicing

Just as with strings, you can access elements in a list using indexing and slicing. The first element of a list has index zero, the second element has index one, and so on. Use square brackets to index:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[1])

Reset

inclinant
```

You can also use negative indices to access items from the end of a list:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[-1])

Reset

obligant
```

Use slicing to extract a sublist. To slice, use square brackets containing a range of indices separated by a colon:

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[1:4])

Reset

['inclinant', 'sed', 'non']
```

Notice that this code returned a sublist containing the elements at indices one, two, and three of phrase. The ending index of the slice is not included.

Omitting the starting index in a slice implies an index of zero, and omitting the ending index implies an index of len(my_list):

```
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']

print(phrase[:3])

print(phrase[3:])

Reset

['Astra', 'inclinant', 'sed']
['non', 'obligant']
```

## List mutability

Lists are mutable, which means that you can change their contents after they are created. You can change an individual item in a list by specifying its index and assigning a new value to it. For example:

```
my_list = ['Macduff', 'Malcolm', 'Duncan', 'Banquo']

my_list[2] = 'Macbeth'

print(my_list)

Reset

['Macduff', 'Malcolm', 'Macbeth', 'Banquo']
```

You can even change a slice of a list using the same logic. The slice can be of any length. The elements in the new list will be inserted in place of the indicated slice: 

```
my_list = ['Macduff', 'Malcolm', 'Macbeth', 'Banquo']

my_list[1:3] = [1, 2, 3, 4]

print(my_list)

Reset

['Macduff', 1, 2, 3, 4, 'Banquo']
```

## List operations

Lists can be combined using the addition operator (+):

```
num_list = [1, 2, 3]

char_list = ['a', 'b', 'c']

num_list + char_list

Reset

[1, 2, 3, 'a', 'b', 'c']
```

They can also be multiplied using the multiplication operator (*):

```
list_a = ['a', 'b', 'c']

list_a * 2

Reset

['a', 'b', 'c', 'a', 'b', 'c']
```

But they cannot be subtracted or divided. 

You can check whether a value is contained in a list by using the in operator:

```
num_list = [2, 4, 6]

print(5 in num_list)

print(5 not in num_list)

Reset

False
True
```

## List methods

Lists are a core Python class. As you’ve learned, classes package data together with tools to work with it. Methods are functions that belong to a class. Lists have a number of built-in methods that are very useful.

## append()

Add an element to the end of a list:

```
my_list = [0, 1, 1, 2, 3]

variable = 5

my_list.append(variable)

print(my_list)

Reset

[0, 1, 1, 2, 3, 5]
```

## insert()

Insert an element at a given position:

```
my_list = ['a', 'b', 'd']

my_list.insert(2, 'c')

print(my_list)

Reset

['a', 'b', 'c', 'd']
```

## remove()

Remove the first occurrence of an item:

```
my_list = ['a', 'b', 'd', 'a']

my_list.remove('a')

print(my_list)

Reset

['b', 'd', 'a']
```

## pop()

Remove the item at the given position in the list, and return it. If no index is specified, pop() removes and returns the last item in the list:

```
my_list = ['a', 'b', 'c']

print(my_list.pop())

print(my_list)

Reset

c
['a', 'b']
```

## clear()

Remove all items:

```
my_list = ['a', 'b', 'c']

my_list.clear()

print(my_list)

Reset

[]
```

## index()

Return the index of the first occurrence of an item in the list:

```
my_list = ['a', 'b', 'c', 'a']

my_list.index('a')

Reset

0
```

## count()

Return the number of times an item occurs in the list:

```
my_list = ['a', 'b', 'c', 'a']

my_list.count('a')

Reset

2
```

## sort()

Sorts the list ascending by default. You can also make a function to decide the sorting criteria:

```
char_list = ['b', 'c', 'a']

num_list = [2, 3, 1]

char_list.sort()

num_list.sort(reverse=True)

print(char_list)

print(num_list)

Reset

['a', 'b', 'c']
[3, 2, 1]
```

## **Additional resources**

- For more information about lists, refer to [An Informal Introduction to Python: Lists](https://docs.python.org/3/tutorial/introduction.html#lists).
    
- For more list methods, refer to [Data Structures: More on Lists](https://docs.python.org/3/tutorial/datastructures.html).